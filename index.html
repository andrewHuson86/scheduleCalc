<!DOCTYPE html>
<!-- I hope you like spaghetti! -->
<!-- Ability to delete people, providers, or applications was removed from the user interface to allow loading stored results, 
		and because those should be permanent items in Barcode -->
<!-- Now uses a temporary object myTempSchedule for all schedule editing, only saves schedule to data when using the save changes button -->
<!-- TODO List:

-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CCSP Schedule Management System</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 10px 20px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            cursor: pointer;
            margin-right: 2px;
        }
        .nav-tab.active {
            background: #007bff;
            color: white;
            border-bottom: 2px solid #007bff;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .form-group {
            margin-bottom: 10px;
			margin-top: 5px;
			padding: 2px;
        }
		.sch-form-group{
			margin-bottom: 10px;
			margin-top: 5px;
			border: 1px solid #ddd;
			border-radius: 4px;
			padding: 2px;
		}
        label {
            display: block;
            margin-bottom: 5px;
			margin-top: 5px;
            font-weight: bold;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
		.careLine{
			width: 100%;
			padding-left: 40px;
			font-size: 12px;
		}
		ul {
			margin-left: 5px;
		}
		ul ul{
			margin-left: 10px;
		}
		li {
			padding-left: 5px;
			font-size: 12px;
			margin-left: 5px;
		}
        button {
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
			margin-bottom: 2px;
			margin-top: 2px;
        }
        button:hover {
            background: #0056b3;
        }
        button.danger {
            background: #dc3545;
        }
		button.saveButton {
			background: #04AA6D;
		}
		#remWeekButton {
			background: #dc3545;
		}
		#addWeekButton {
			background: #04AA6D;
		}
        button.danger:hover {
            background: #c82333;
        }
        .list-item {
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .schedule-grid {
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 1px;
            border: 1px solid #ddd;
            margin: 20px 0;
        }
        .schedule-cell {
            border: 1px solid #ddd;
            padding: 5px;
            min-height: 60px;
            background: white;
        }
        .schedule-header {
            background: #f8f9fa;
            font-weight: bold;
            text-align: center;
        }
        .period {
            background: #e3f2fd;
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 12px;
        }
        .active-app {
            background: #d4edda;
            border-color: #c3e6cb;
        }
        .error {
            color: #dc3545;
            font-size: 12px;
            margin-top: 5px;
        }
		.warning {
            color: #f0ad4e;
            font-size: 12px;
            margin-top: 5px;
        }
        .section {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 4px;
        }
        .section h3 {
            margin-top: 0;
            color: #007bff;
        }
        .time-input {
            width: 120px;
            display: inline-block;
            margin-right: 10px;
        }
        .schedule-cell.empty-week {
            background-color: #f0f0f0;
            color: #999;
        }
		.checkbox-group {
		  display: flex; 
		  justify-content: space-around; 
		  align-items: flex-start;
		  padding: 2px 4px;
		  margin-top: 5px;
		  width: 100%;
		}
		.buttonRow {
		  display: flex;
		  justify-content: flex-end;
		}
		.checkbox-item {
		  display: flex; 
		  flex-direction: column; 
		  align-items: center;
		  padding: 2px 4px;
		  margin-top: 2px;
		  text-align: center; 
		}
		.period-group {
		  display: flex; 
		  justify-content: space-around;
		  align-items: flex-start; 
		  padding: 2px 4px;
		  margin-top: 5px;
		  width: 60%; 
		  font-size: 14px;
		}
		.period-item {
		  display: flex;
		  align-items: center;
		  text-align: center; 
		  padding: 2px 4px;
		  margin-top: 2px;
		  font-size: 14px;
		}
		.checkbox-item label {
			font-weight: bold;
			font-size: 20px;
		  margin-bottom: 5px;
		}
		.minuteInput {
		font-family: monospace;
		font-size: 14px;
		 width: 4em;
		}
		.hourSelection {
		font-family: monospace;
		font-size: 14px;
		 width: 4em;
		}
		.APMSelector {
		font-family: monospace;
		font-size: 14px;
		 width: 4em;
		}
		.reporting_checkbox {
			display: flex;
			flex-direction: row;
			justify-content: flex-start;
			height: 20px;
			margin-top: 2px;
			margin-bottom: 2px;
			align-items: center;
		}
		.reporting_checkbox label {
			font-size: 10px;
			font-weight: bold;
			margin-left: 5px;
		}
		.careResultLine{
			width: 100%;
			padding-left: 40px;
			font-size: 12px;
		}
		.deleteAll {
			height: 26px;
			display: flex;
			justify-content: flex-end;
		}
		.deleteAll button {
			font-size: 10px;
			font-weight: bold;
			text-align: center;
			padding: 3px;
			padding-top: 6px;
			padding-bottom: 6px;
			color: white;
			curser: pointer;
		}
    </style>
</head>
<body>
    <div class="container">
		<div class="deleteAll"><button class="danger" onclick="removeAllStoredData()">Delete Stored Data</button></div>
		<div id="exitLoadedState" class="deleteAll"></div>
        <h1>CCSP Schedule Management System</h1>
		<div class="reporting_checkbox"><div><input type="checkbox" id="repCheckbox" onchange="toggleVerboseReporting()" checked="false"></div><div><label for="repCheckbox">Verbose Reporting</label></div></div>
        <div class="nav-tabs">
            <div class="nav-tab active" onclick="showTab('people')">People</div>
            <div class="nav-tab" onclick="showTab('providers')">Providers</div>
            <div class="nav-tab" onclick="showTab('applications')">Applications</div>
            <div class="nav-tab" onclick="showTab('household')">Household</div>
            <div class="nav-tab" onclick="showTab('activities')">Activities</div>
            <div class="nav-tab" onclick="showTab('provider-links')">Provider Links</div>
            <div class="nav-tab" onclick="showTab('schedules')">Schedules</div>
            <div class="nav-tab" onclick="showTab('calculation')">Calculate Care</div>
			<div class="nav-tab" onclick="showTab('savedResults')">Saved Results</div>
        </div>

        <!-- People Tab -->
        <div id="people" class="tab-content active">
            <div class="section">
                <h3>Add New Person</h3>
                <div class="form-group">
                    <label>Name:</label>
                    <input type="text" id="personName" placeholder="Enter person's name">
                    <div id="personNameError" class="error"></div>
                </div>
                <div class="form-group">
                    <label>Birthdate:</label>
                    <input type="date" id="personBirthdate">
                    <div id="personBirthdateError" class="error"></div>
                </div>
                <button onclick="addPerson()">Add Person</button>
            </div>
            
            <div class="section">
                <h3>People List</h3>
                <div id="peopleList"></div>
            </div>
        </div>

        <!-- Providers Tab -->
        <div id="providers" class="tab-content">
            <div class="section">
                <h3>Add New Provider</h3>
                <div class="form-group">
                    <label>Name:</label>
                    <input type="text" id="providerName" placeholder="Enter provider name">
                </div>
                <div class="form-group">
                    <label>Type:</label>
                    <select id="providerType">
                        <option value="C">Center (C)</option>
                        <option value="F">FFN (F)</option>
                        <option value="H">LFH (H)</option>
                    </select>
                </div>
		<div class="form-group">
                    <label>Region:</label>
                    <select id="providerRegion">
                        <option value="1">Region 1</option>
                        <option value="S">Spokane</option>
                        <option value="2">Region 2</option>
			<option value="3">Region 3</option>
			<option value="4">Region 4</option>
			<option value="5">Region 5</option>
			<option value="6">Region 6</option>
                    </select>
                </div>
                <button onclick="addProvider()">Add Provider</button>
            </div>
            
            <div class="section">
                <h3>Providers List</h3>
                <div id="providersList"></div>
            </div>
        </div>

        <!-- Applications Tab -->
        <div id="applications" class="tab-content">
            <div class="section">
                <h3>Add New Application</h3>
                <div class="form-group">
                    <label>Head of Household:</label>
                    <select id="headOfHousehold">
                        <option value="">Select a person</option>
                    </select>
                </div>
                <button onclick="addApplication()">Add Application</button>
            </div>
            
            <div class="section">
                <h3>Applications List</h3>
                <div id="applicationsList"></div>
            </div>
            
            <div class="section">
                <h3>Active Application</h3>
                <div id="activeApplication">No active application selected</div>
            </div>
        </div>

        <!-- Household Tab -->
        <div id="household" class="tab-content">
            <div class="section">
                <h3>Add Household Member</h3>
                <div id="householdForm">
                    <p>Please select an active application first.</p>
                </div>
            </div>
            
            <div class="section">
                <h3>Household Members</h3>
                <div id="householdList"></div>
            </div>
        </div>

        <!-- Activities Tab -->
        <div id="activities" class="tab-content">
            <div class="section">
                <h3>Add Activity</h3>
                <div id="activityForm">
                    <p>Please select an active application first.</p>
                </div>
            </div>
            
            <div class="section">
                <h3>Activities</h3>
                <div id="activitiesList"></div>
            </div>
        </div>

        <!-- Provider Links Tab -->
        <div id="provider-links" class="tab-content">
            <div class="section">
                <h3>Add Provider-Child Link</h3>
                <div id="providerLinkForm">
                    <p>Please select an active application first.</p>
                </div>
            </div>
            
            <div class="section">
                <h3>Provider-Child Links</h3>
                <div id="providerLinksList"></div>
            </div>
        </div>

        <!-- Schedules Tab -->
        <div id="schedules" class="tab-content">
            <div class="section">
                <h3>Edit Schedule</h3>
                <div class="form-group">
                    <label>Select Schedule:</label>
                    <select id="scheduleSelector" onchange="loadSchedule()">
                        <option value="">Select a schedule to edit</option>
                    </select>
                </div>
                
                <div id="scheduleEditor">
				<h3>Schedule Editor</h3>
                    <button onclick="clearSchedule()" class="danger">Clear Schedule</button><button id="saveChangesButton" onclick="saveTempSchedule()" class="saveButton">Save Changes</button>
                    
                    <div class="sch-form-group">
                        <!-- Instead of selecting a day from a dropdown, have checkbox for each day Sun->Sat, user can select multiple weekdays for the week to add the period to -->
                        <label for="dayCheckboxes">Day(s):</label>
						<!-- Days -->
						<div class="checkbox-group" id="dayCheckboxes">
						 <div class="checkbox-item"><label for="SunBox">Sun</label> <input type="checkbox" id="SunBox" onchange="checkDayBoxes(1)" name="SundayBox"></div>
						 <div class="checkbox-item"><label for="MonBox">Mon</label><input type="checkbox" id="MonBox" onchange="checkDayBoxes(2)" name="MondayBox"></div>
						 <div class="checkbox-item"><label for="TueBox">Tue</label><input type="checkbox" id="TueBox" onchange="checkDayBoxes(3)" name="TuesdayBox"></div>
						 <div class="checkbox-item"><label for="WedBox">Wed</label><input type="checkbox" id="WedBox" onchange="checkDayBoxes(4)" name="WednesdayBox"></div>
						 <div class="checkbox-item"><label for="ThuBox">Thu</label><input type="checkbox" id="ThuBox" onchange="checkDayBoxes(5)" name="ThursdayBox"></div>
						 <div class="checkbox-item"><label for="FriBox">Fri</label><input type="checkbox" id="FriBox" onchange="checkDayBoxes(6)" name="FridayBox"></div>
						 <div class="checkbox-item"><label for="SatBox">Sat</label><input type="checkbox" id="SatBox" onchange="checkDayBoxes(7)" name="SaturdayBox"></div>
						</div>
						<!-- Week -->
						<label for="periodWeek">Week:</label>
                        <select id="periodWeek" onchange="modifyBoxes()">
                            <option value="1">Week 1</option>
                            <option value="2">Week 2</option>
                            <option value="3">Week 3</option>
                            <option value="4">Week 4</option>
                        </select>
						<div id="scheduleEditorButtons"></div>
						<!-- Period -->
						<label for="myPeriodGroup">Period:</label>
                        <div class="period-group" id="myPeriodGroup">
						 <div class="period-item">
							<label>Start Time:</label> 
							<select id="startHr" class="hourSelection">
								<option value = "1">1</option>
								<option value = "2">2</option>
								<option value = "3">3</option>
								<option value = "4">4</option>
								<option value = "5">5</option>
								<option value = "6">6</option>
								<option value = "7">7</option>
								<option value = "8" selected>8</option>
								<option value = "9">9</option>
								<option value = "10">10</option>
								<option value = "11">11</option>
								<option value = "12">12</option>
							</select>
							<label>:</label>
							  <input type="text" maxlength="2" pattern="[0-9][0-9]" id="startMins" name="startMinutes" class="minuteInput" value ="00">
							  <select id="startAPM" class="APMSelector">
							  <option value="AM" selected>AM</option>
							   <option value="PM">PM</option>
							  </select>
							  </div>
							  
							 <div class="period-item">
							<label>End Time:</label> 
							<select id="endHr" class="hourSelection">
							<option value = "1">1</option>
							<option value = "2">2</option>
							<option value = "3">3</option>
							<option value = "4">4</option>
							<option value = "5" selected>5</option>
							<option value = "6">6</option>
							<option value = "7">7</option>
							<option value = "8">8</option>
							<option value = "9">9</option>
							<option value = "10">10</option>
							<option value = "11">11</option>
							<option value = "12">12</option>
							</select>
							<label>:</label>
							  <input type="text" maxlength="2" pattern="[0-9][0-9]" id="endMins" name="startMinutes" class="minuteInput" value ="00">
							  <select id="endAPM" class="APMSelector">
							  <option value="AM">AM</option>
							   <option value="PM" selected>PM</option>
							  </select>
							  </div>
						
                        <div class="period-item"><button onclick="addPeriods()">Add Period</button></div>
						</div>
                        <div id="periodError" class="error"></div>
                    </div>
                    
                    <div id="scheduleDisplay"></div>
                </div>
            </div>
        </div>

        <!-- Calculate Care Tab -->
        <div id="calculation" class="tab-content">
            <div class="section">
                <h3>Calculate Care</h3>
                <div id="calculationForm">
                    <p>Please select an active application first.</p>
                </div>
                
                <div class="section">
                    <h3>Calculation Results</h3>
                    <div id="calculationResults">
                        <p>No calculation performed yet.</p>
                    </div>
                </div>
            </div>
        </div>
		<!-- Saved Results Care Tab -->
        <div id="savedResults" class="tab-content">
            <div class="section">
                <h3>Saved Care results</h3>
                <div id="savedResultsForm">
                    <p>Please select an active application first.</p>
					<div id ="recalculateForm"></div>
                </div>
                <div class="section">
                    <h3>Care Results</h3>
                    <div id="selectedCareResult">
                        <p>No Result yet selected.</p>
                    </div>
					<div id="recalculationSection"></div>
                </div>
            </div>
        </div>
		
    </div>
<script>
// Data structures and storage

// RATES TABLE
const RATES_TABLE = Object.freeze([ { prrType: "C", ageGroup: "All", region: "A", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "NSHB", rate: 150.00},{ prrType: "H", ageGroup: "All", region: "A", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "NSHB", rate: 150.00},{ prrType: "C", ageGroup: "Infant", region: "1", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 62.05}, { prrType: "C", ageGroup: "Pre-School", region: "1", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 53.18}, { prrType: "C", ageGroup: "School-Age", region: "1", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 53.36}, { prrType: "C", ageGroup: "Toddler", region: "1", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 56.14}, { prrType: "C", ageGroup: "Infant", region: "1", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 31.03}, { prrType: "C", ageGroup: "Pre-School", region: "1", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 26.59}, { prrType: "C", ageGroup: "School-Age", region: "1", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 26.68}, { prrType: "C", ageGroup: "Toddler", region: "1", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 28.07}, { prrType: "H", ageGroup: "Enh Toddler", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 49.23}, { prrType: "H", ageGroup: "Infant", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 49.23}, { prrType: "H", ageGroup: "Pre-School", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 40}, { prrType: "H", ageGroup: "School-Age", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 36.59}, { prrType: "H", ageGroup: "Toddler", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 47.09}, { prrType: "H", ageGroup: "Enh Toddler", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 24.62}, { prrType: "H", ageGroup: "Infant", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 24.62}, { prrType: "H", ageGroup: "Pre-School", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 20}, { prrType: "H", ageGroup: "School-Age", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 18.3}, { prrType: "H", ageGroup: "Toddler", region: "1", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 23.55}, { prrType: "F", ageGroup: "All", region: "1", begDt: "2023-07-01", endDt: "2024-06-30", unitType: "Hour", rate: 3.85}, { prrType: "C", ageGroup: "Infant", region: "2", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 59.09}, { prrType: "C", ageGroup: "Pre-School", region: "2", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 44.77}, { prrType: "C", ageGroup: "School-Age", region: "2", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 32.73}, { prrType: "C", ageGroup: "Toddler", region: "2", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 49.09}, { prrType: "C", ageGroup: "Infant", region: "2", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 29.55}, { prrType: "C", ageGroup: "Pre-School", region: "2", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 22.39}, { prrType: "C", ageGroup: "School-Age", region: "2", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 16.37}, { prrType: "C", ageGroup: "Toddler", region: "2", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 24.55}, { prrType: "H", ageGroup: "Enh Toddler", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 66}, { prrType: "H", ageGroup: "Infant", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 66}, { prrType: "H", ageGroup: "Pre-School", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 48}, { prrType: "H", ageGroup: "School-Age", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 40}, { prrType: "H", ageGroup: "Toddler", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 59.09}, { prrType: "H", ageGroup: "Enh Toddler", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 33}, { prrType: "H", ageGroup: "Infant", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 33}, { prrType: "H", ageGroup: "Pre-School", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 24}, { prrType: "H", ageGroup: "School-Age", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 20}, { prrType: "H", ageGroup: "Toddler", region: "2", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 29.55}, { prrType: "F", ageGroup: "All", region: "2", begDt: "2023-07-01", endDt: "2024-06-30", unitType: "Hour", rate: 3.85}, { prrType: "C", ageGroup: "Pre-School", region: "3", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 72.5}, { prrType: "C", ageGroup: "School-Age", region: "3", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 65.45}, { prrType: "C", ageGroup: "Toddler", region: "3", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 80.36}, { prrType: "C", ageGroup: "Pre-School", region: "3", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 36.25}, { prrType: "C", ageGroup: "School-Age", region: "3", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 32.73}, { prrType: "C", ageGroup: "Toddler", region: "3", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 40.18}, { prrType: "H", ageGroup: "Enh Toddler", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 65}, { prrType: "H", ageGroup: "Infant", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 65}, { prrType: "H", ageGroup: "Pre-School", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 54.18}, { prrType: "H", ageGroup: "School-Age", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 49.23}, { prrType: "H", ageGroup: "Toddler", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 59.09}, { prrType: "H", ageGroup: "Enh Toddler", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 32.5}, { prrType: "H", ageGroup: "Infant", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 32.5}, { prrType: "H", ageGroup: "Pre-School", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 27.09}, { prrType: "H", ageGroup: "School-Age", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 24.62}, { prrType: "H", ageGroup: "Toddler", region: "3", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 29.55}, { prrType: "F", ageGroup: "All", region: "3", begDt: "2023-07-01", endDt: "2024-06-30", unitType: "Hour", rate: 3.85}, { prrType: "C", ageGroup: "Infant", region: "4", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 113.64}, { prrType: "C", ageGroup: "Pre-School", region: "4", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 85.68}, { prrType: "C", ageGroup: "School-Age", region: "4", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 90.64}, { prrType: "C", ageGroup: "Toddler", region: "4", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 101.59}, { prrType: "C", ageGroup: "Infant", region: "4", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 56.82}, { prrType: "C", ageGroup: "Pre-School", region: "4", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 42.84}, { prrType: "C", ageGroup: "School-Age", region: "4", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 45.32}, { prrType: "C", ageGroup: "Toddler", region: "4", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 50.8}, { prrType: "H", ageGroup: "Enh Toddler", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 81.82}, { prrType: "H", ageGroup: "Infant", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 81.82}, { prrType: "H", ageGroup: "Pre-School", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 68.95}, { prrType: "H", ageGroup: "School-Age", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 60}, { prrType: "H", ageGroup: "Toddler", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 75}, { prrType: "H", ageGroup: "Enh Toddler", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 40.91}, { prrType: "H", ageGroup: "Infant", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 40.91}, { prrType: "H", ageGroup: "Pre-School", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 34.48}, { prrType: "H", ageGroup: "School-Age", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 30}, { prrType: "H", ageGroup: "Toddler", region: "4", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 37.5}, { prrType: "F", ageGroup: "All", region: "4", begDt: "2023-07-01", endDt: "2024-06-30", unitType: "Hour", rate: 3.85}, { prrType: "C", ageGroup: "School-Age", region: "5", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 54.18}, { prrType: "C", ageGroup: "Toddler", region: "5", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 64}, { prrType: "C", ageGroup: "School-Age", region: "5", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 27.09}, { prrType: "C", ageGroup: "Toddler", region: "5", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 32}, { prrType: "H", ageGroup: "Enh Toddler", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 59.09}, { prrType: "H", ageGroup: "Infant", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 59.09}, { prrType: "H", ageGroup: "Pre-School", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 49.23}, { prrType: "H", ageGroup: "School-Age", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 44.32}, { prrType: "H", ageGroup: "Toddler", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 59.09}, { prrType: "H", ageGroup: "Enh Toddler", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 29.55}, { prrType: "H", ageGroup: "Infant", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 29.55}, { prrType: "H", ageGroup: "Pre-School", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 24.62}, { prrType: "H", ageGroup: "School-Age", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 22.16}, { prrType: "H", ageGroup: "Toddler", region: "5", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 29.55}, { prrType: "F", ageGroup: "All", region: "5", begDt: "2023-07-01", endDt: "2024-06-30", unitType: "Hour", rate: 3.85}, { prrType: "C", ageGroup: "Infant", region: "6", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 77}, { prrType: "C", ageGroup: "Pre-School", region: "6", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 57.73}, { prrType: "C", ageGroup: "School-Age", region: "6", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 50.23}, { prrType: "C", ageGroup: "Toddler", region: "6", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 67.5}, { prrType: "C", ageGroup: "Infant", region: "6", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 38.5}, { prrType: "C", ageGroup: "Pre-School", region: "6", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 28.87}, { prrType: "C", ageGroup: "School-Age", region: "6", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 25.12}, { prrType: "C", ageGroup: "Toddler", region: "6", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 33.75}, { prrType: "H", ageGroup: "Enh Toddler", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 59.09}, { prrType: "H", ageGroup: "Infant", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 59.09}, { prrType: "H", ageGroup: "Pre-School", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 53}, { prrType: "H", ageGroup: "School-Age", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 45}, { prrType: "H", ageGroup: "Toddler", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 55}, { prrType: "H", ageGroup: "Enh Toddler", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 29.55}, { prrType: "H", ageGroup: "Infant", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 29.55}, { prrType: "H", ageGroup: "Pre-School", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 26.5}, { prrType: "H", ageGroup: "School-Age", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 22.5}, { prrType: "H", ageGroup: "Toddler", region: "6", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 27.5}, { prrType: "F", ageGroup: "All", region: "6", begDt: "2023-07-01", endDt: "2024-06-30", unitType: "Hour", rate: 3.85}, { prrType: "C", ageGroup: "School-Age", region: "S", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 49}, { prrType: "C", ageGroup: "Toddler", region: "S", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 56.59}, { prrType: "C", ageGroup: "School-Age", region: "S", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 24.5}, { prrType: "C", ageGroup: "Toddler", region: "S", begDt: "2023-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 28.3}, { prrType: "H", ageGroup: "Enh Toddler", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 48}, { prrType: "H", ageGroup: "Infant", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 48}, { prrType: "H", ageGroup: "Pre-School", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 45}, { prrType: "H", ageGroup: "School-Age", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 45}, { prrType: "H", ageGroup: "Toddler", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Full Day", rate: 48}, { prrType: "H", ageGroup: "Enh Toddler", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 24}, { prrType: "H", ageGroup: "Infant", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 24}, { prrType: "H", ageGroup: "Pre-School", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 22.5}, { prrType: "H", ageGroup: "School-Age", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 22.5}, { prrType: "H", ageGroup: "Toddler", region: "S", begDt: "2023-07-01", endDt: "2025-06-30", unitType: "Half Day", rate: 24}, { prrType: "F", ageGroup: "All", region: "S", begDt: "2023-07-01", endDt: "2024-06-30", unitType: "Hour", rate: 3.85}, { prrType: "F", ageGroup: "All", region: "1", begDt: "2024-07-01", endDt: "2025-06-30", unitType: "Hour", rate: 4}, { prrType: "F", ageGroup: "All", region: "2", begDt: "2024-07-01", endDt: "2025-06-30", unitType: "Hour", rate: 4}, { prrType: "F", ageGroup: "All", region: "3", begDt: "2024-07-01", endDt: "2025-06-30", unitType: "Hour", rate: 4}, { prrType: "F", ageGroup: "All", region: "4", begDt: "2024-07-01", endDt: "2025-06-30", unitType: "Hour", rate: 4}, { prrType: "F", ageGroup: "All", region: "5", begDt: "2024-07-01", endDt: "2025-06-30", unitType: "Hour", rate: 4}, { prrType: "F", ageGroup: "All", region: "6", begDt: "2024-07-01", endDt: "2025-06-30", unitType: "Hour", rate: 4}, { prrType: "F", ageGroup: "All", region: "S", begDt: "2024-07-01", endDt: "2025-06-30", unitType: "Hour", rate: 4}, { prrType: "H", ageGroup: "Enh Toddler", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 60}, { prrType: "H", ageGroup: "Infant", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 60}, { prrType: "H", ageGroup: "Pre-School", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 51.14}, { prrType: "H", ageGroup: "School-Age", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 60}, { prrType: "H", ageGroup: "Toddler", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 60}, { prrType: "H", ageGroup: "Enh Toddler", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 30}, { prrType: "H", ageGroup: "Infant", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 30}, { prrType: "H", ageGroup: "Pre-School", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 25.57}, { prrType: "H", ageGroup: "School-Age", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 30}, { prrType: "H", ageGroup: "Toddler", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 30}, { prrType: "F", ageGroup: "All", region: "1", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Hour", rate: 4.5}, { prrType: "H", ageGroup: "Enh Toddler", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 80}, { prrType: "H", ageGroup: "Infant", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 80}, { prrType: "H", ageGroup: "Pre-School", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 63.64}, { prrType: "H", ageGroup: "School-Age", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 50}, { prrType: "H", ageGroup: "Toddler", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 72.73}, { prrType: "H", ageGroup: "Enh Toddler", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 40}, { prrType: "H", ageGroup: "Infant", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 40}, { prrType: "H", ageGroup: "Pre-School", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 31.82}, { prrType: "H", ageGroup: "School-Age", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 25}, { prrType: "H", ageGroup: "Toddler", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 36.37}, { prrType: "F", ageGroup: "All", region: "2", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Hour", rate: 4.5}, { prrType: "H", ageGroup: "Enh Toddler", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 82}, { prrType: "H", ageGroup: "Infant", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 82}, { prrType: "H", ageGroup: "Pre-School", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 70}, { prrType: "H", ageGroup: "School-Age", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 75}, { prrType: "H", ageGroup: "Toddler", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 77.27}, { prrType: "H", ageGroup: "Enh Toddler", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 41}, { prrType: "H", ageGroup: "Infant", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 41}, { prrType: "H", ageGroup: "Pre-School", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 35}, { prrType: "H", ageGroup: "School-Age", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 37.5}, { prrType: "H", ageGroup: "Toddler", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 38.64}, { prrType: "F", ageGroup: "All", region: "3", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Hour", rate: 4.5}, { prrType: "H", ageGroup: "Enh Toddler", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 96.55}, { prrType: "H", ageGroup: "Infant", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 96.55}, { prrType: "H", ageGroup: "Pre-School", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 90}, { prrType: "H", ageGroup: "School-Age", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 78.79}, { prrType: "H", ageGroup: "Toddler", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 98.49}, { prrType: "H", ageGroup: "Enh Toddler", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 48.28}, { prrType: "H", ageGroup: "Infant", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 48.28}, { prrType: "H", ageGroup: "Pre-School", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 45}, { prrType: "H", ageGroup: "School-Age", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 39.4}, { prrType: "H", ageGroup: "Toddler", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 49.25}, { prrType: "F", ageGroup: "All", region: "4", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Hour", rate: 4.5}, { prrType: "H", ageGroup: "Enh Toddler", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 90.91}, { prrType: "H", ageGroup: "Infant", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 90.91}, { prrType: "H", ageGroup: "Pre-School", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 65}, { prrType: "H", ageGroup: "School-Age", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 49.24}, { prrType: "H", ageGroup: "Toddler", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 70}, { prrType: "H", ageGroup: "Enh Toddler", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 45.46}, { prrType: "H", ageGroup: "Infant", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 45.46}, { prrType: "H", ageGroup: "Pre-School", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 32.5}, { prrType: "H", ageGroup: "School-Age", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 24.62}, { prrType: "H", ageGroup: "Toddler", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 35}, { prrType: "F", ageGroup: "All", region: "5", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Hour", rate: 4.5}, { prrType: "H", ageGroup: "Enh Toddler", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 90.91}, { prrType: "H", ageGroup: "Infant", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 90.91}, { prrType: "H", ageGroup: "Pre-School", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 63.64}, { prrType: "H", ageGroup: "School-Age", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 68.94}, { prrType: "H", ageGroup: "Toddler", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 68.94}, { prrType: "H", ageGroup: "Enh Toddler", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 45.46}, { prrType: "H", ageGroup: "Infant", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 45.46}, { prrType: "H", ageGroup: "Pre-School", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 31.82}, { prrType: "H", ageGroup: "School-Age", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 34.47}, { prrType: "H", ageGroup: "Toddler", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 34.47}, { prrType: "F", ageGroup: "All", region: "6", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Hour", rate: 4.5}, { prrType: "H", ageGroup: "Enh Toddler", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 56}, { prrType: "H", ageGroup: "Infant", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 56}, { prrType: "H", ageGroup: "Pre-School", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 50}, { prrType: "H", ageGroup: "School-Age", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 50}, { prrType: "H", ageGroup: "Toddler", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Full Day", rate: 55}, { prrType: "H", ageGroup: "Enh Toddler", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 28}, { prrType: "H", ageGroup: "Infant", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 28}, { prrType: "H", ageGroup: "Pre-School", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 25}, { prrType: "H", ageGroup: "School-Age", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 25}, { prrType: "H", ageGroup: "Toddler", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Half Day", rate: 27.5}, { prrType: "F", ageGroup: "All", region: "S", begDt: "2025-07-01", endDt: "2999-12-31", unitType: "Hour", rate: 4.5}]);
// END OF RATES TABLE

//SVC_CODES_TABLE
const SVC_CODES_TABLE = Object.freeze([ { type: "CCFDU", svcCode: "2950", desc: "LIC CENTER FULL DAY", begDt: "1990-01-01", endDt: "2026-06-30"}, { type: "CCHDU", svcCode: "2947", desc: "LIC CENTER HALF DAY", begDt: "1990-01-01", endDt: "2026-06-30"}, { type: "CCNSHB", svcCode: "2937", desc: "LIC CENTER NSHB", begDt: "1990-01-01", endDt: "2999-12-31"}, { type: "CCOTU", svcCode: "2982", desc: "OVERTIME CARE CENTER", begDt: "1990-01-01", endDt: "2026-06-30"}, { type: "CCSDU", svcCode: "2901", desc: "WCCC Center-half day-School", begDt: "1990-01-01", endDt: "2026-06-30"}, { type: "FFNClHome", svcCode: "2941/70/71", desc: "CARE IN CL'S HOME", begDt: "1990-01-01", endDt: "2999-12-31"}, { type: "FFNMutHome", svcCode: "2941/70/71", desc: "CARE IN MUTUAL HOME", begDt: "1990-01-01", endDt: "2999-12-31"}, { type: "FFNPrrHome", svcCode: "2949", desc: "CARE IN PRR HOME", begDt: "1990-01-01", endDt: "2999-12-31"}, { type: "LFHFT", svcCode: "2910", desc: "LFH FT", begDt: "1990-01-01", endDt: "2026-08-31"}, { type: "LFHNSHB", svcCode: "2938", desc: "LIC FAMILY HOME NSHB", begDt: "1990-01-01", endDt: "2999-12-31"}, { type: "LFHOT", svcCode: "2918", desc: "LFH Overtime", begDt: "1990-01-01", endDt: "2026-08-31"}, { type: "LFHPT", svcCode: "2911", desc: "LFH PT", begDt: "1990-01-01", endDt: "2026-08-31"}, { type: "LFHSchoolFT", svcCode: "2916", desc: "LFH FT School Age", begDt: "1990-01-01", endDt: "2026-08-31"}, { type: "LFHSchoolFTPartial", svcCode: "2902", desc: "LFH FT 3/4 Day", begDt: "1990-01-01", endDt: "2026-08-31"}, { type: "LFHSchoolPT", svcCode: "2919", desc: "LFH PT School Age", begDt: "1990-01-01", endDt: "2026-08-31"}, { type: "LFHSchoolPTPartial", svcCode: "2952", desc: "LFH PT 3/4 Day", begDt: "1990-01-01", endDt: "2026-08-31"}, { type: "LFHSleep", svcCode: "2946", desc: "LFH Sleep Time", begDt: "1990-01-01", endDt: "2026-08-31"}, { type: "CCFT", svcCode: "2961", desc: "CC FT", begDt: "2026-07-01", endDt: "2026-08-31"}, { type: "CCOT", svcCode: "2965", desc: "CC Overtime", begDt: "2026-07-01", endDt: "2026-08-31"}, { type: "CCPT", svcCode: "2962", desc: "CC PT", begDt: "2026-07-01", endDt: "2026-08-31"}, { type: "CCSchoolFT", svcCode: "2914", desc: "CC FT School Age", begDt: "2026-07-01", endDt: "2026-08-31"}, { type: "CCSchoolPT", svcCode: "2903", desc: "CC PT School Age", begDt: "2026-07-01", endDt: "2026-08-31"}, { type: "CCSchoolPT", svcCode: "0305", desc: "CC PT School Age PROSP", begDt: "2026-09-10", endDt: "2999-12-31"}, { type: "CCSleep", svcCode: "2966", desc: "CC Sleep Time", begDt: "2026-07-01", endDt: "2026-08-31"}, { type: "CCFT", svcCode: "0301", desc: "CC FT PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "CCOT", svcCode: "0308", desc: "CC Overtime PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "CCPT", svcCode: "0302", desc: "CC PT PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "CCSchoolFT", svcCode: "0303", desc: "CC FT School Age PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "CCSleep", svcCode: "0307", desc: "CC Sleep Time PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "LFHFT", svcCode: "0501", desc: "LFH FT PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "LFHOT", svcCode: "0508", desc: "LFH Overtime PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "LFHPT", svcCode: "0502", desc: "LFH PT PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "LFHSchoolFT", svcCode: "0503", desc: "LFH FT School Age PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "LFHSchoolFTPartial", svcCode: "0504", desc: "LFH FT 3/4 Day PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "LFHSchoolPT", svcCode: "0505", desc: "LFH PT School Age PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "LFHSchoolPTPartial", svcCode: "0506", desc: "LFH PT 3/4 Day PROSP", begDt: "2026-09-01", endDt: "2999-12-31"}, { type: "LFHSleep", svcCode: "0507", desc: "LFH Sleep Time PROSP", begDt: "2026-09-01", endDt: "2999-12-31"} ]);
// END OF SVC_CODES_TABLE

// AGE_GROUPS_TABLE
const AGE_GROUPS_TABLE = Object.freeze([{ prrType: "C", ageGroup: "Infant", minMon: 0, maxMon: 11, schFlag: null, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "C", ageGroup: "Toddler", minMon: 12, maxMon: 29, schFlag: null, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "C", ageGroup: "Pre-School", minMon: 30, maxMon: 83, schFlag: false, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "C", ageGroup: "Pre-School", minMon: 30, maxMon: 49, schFlag: true, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "C", ageGroup: "School-Age", minMon: 50, maxMon: 252, schFlag: true, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "C", ageGroup: "School-Age", minMon: 84, maxMon: 252, schFlag: false, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "H", ageGroup: "Infant", minMon: 0, maxMon: 11, schFlag: null, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "H", ageGroup: "Enh Toddler", minMon: 12, maxMon: 17, schFlag: null, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "H", ageGroup: "Toddler", minMon: 18, maxMon: 29, schFlag: null, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "H", ageGroup: "Pre-School", minMon: 30, maxMon: 83, schFlag: false, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "H", ageGroup: "Pre-School", minMon: 30, maxMon: 49, schFlag: true, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "H", ageGroup: "School-Age", minMon: 50, maxMon: 252, schFlag: true, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "H", ageGroup: "School-Age", minMon: 84, maxMon: 252, schFlag: false, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "F", ageGroup: "All", minMon: 0, maxMon: 252, schFlag: true, begDt: "1990-01-01", endDt: "2999-12-31"}, { prrType: "F", ageGroup: "All", minMon: 0, maxMon: 252, schFlag: false, begDt: "1990-01-01", endDt: "2999-12-31"}]);
// END OF AGE_GROUPS_TABLE

// CALC_FUNCTION_TABLE
const CALC_FUNCTION_TABLE = Object.freeze([{ type: "H", func: "MONTHLYUNITCALC", begDt: "1990-01-01", endDt: "2999-12-31" },{ type: "C", func: "DAILYUNITCALC", begDt: "1990-01-01", endDt: "2026-06-30" },{ type: "F", func: "FFNCALCHRLY", begDt: "1990-01-01", endDt: "2999-12-31" },{ type: "C", func: "MONTHLYUNITCALC", begDt: "2026-07-01", endDt: "2999-12-31" }]);
//END OF CALC_FUNCTION_TABLE

let actualData = {
	people: JSON.parse(localStorage.getItem('people') || '[]'),
	providers: JSON.parse(localStorage.getItem('providers') || '[]'),
	applications: JSON.parse(localStorage.getItem('applications') || '[]'),
	householdMembers: JSON.parse(localStorage.getItem('householdMembers') || '[]'),
	activities: JSON.parse(localStorage.getItem('activities') || '[]'),
	providerLinks: JSON.parse(localStorage.getItem('providerLinks') || '[]'),
	schedules: JSON.parse(localStorage.getItem('schedules') || '[]'),
	savedResults: JSON.parse(localStorage.getItem('savedResults') || '[]'),
	resultLines: JSON.parse(localStorage.getItem('resultLines') || '[]'),
	shortSchedules: JSON.parse(localStorage.getItem('shortSchedules') || '[]'),
	activeApplicationId: localStorage.getItem('activeApplicationId') || null
};

let myTempData = {
	people: [],
	providers: [],
	applications: [],
	householdMembers: [],
	activities: [],
	providerLinks: [],
	schedules: [],
	savedResults: [],
	resultLines: [],
	shortSchedules: [],
	activeApplicationId:  null
};

// usingTemp true will cause data to point to myTempData
let usingTemp = false;
let nextTempScheduleId = 1;
let myTempSchedule = createTempEmptySchedule('A');
let selectedScheduleId = null;
let mySelectedIndex = null;


// Create a proxy object for data, most of the code will reference data which can be actual or tempData
// Only saving results accesses actualData directly
let data = new Proxy({}, {
  get: function(target, prop) {
    return usingTemp ? myTempData[prop] : actualData[prop];
  },
  set: function(target, prop, value) {
    if (usingTemp) {
      myTempData[prop] = value;
    } else {
      actualData[prop] = value;
    }
    return true;
  },
  deleteProperty: function(target, prop) {
    if (usingTemp) {
      delete myTempData[prop];
    } else {
      delete actualData[prop];
    }
    return true;
  },
  has: function(target, prop) {
    return usingTemp ? prop in myTempData : prop in actualData;
  },
  ownKeys: function(target) {
    return usingTemp ? Object.keys(myTempData) : Object.keys(actualData);
  }
});

// Toggle function
function toggleDataSource() 
{
	usingTemp = !usingTemp;
	if(usingTemp)
	{
		document.getElementById('exitLoadedState').innerHTML = `<button class="danger" onclick="toggleDataSource()"> Exit Loaded State </button>`;
	}
	else
	{
		document.getElementById('exitLoadedState').innerHTML = '';
	}
	clearTempData();
	if(verboseReporting)
	{
		console.log(`Switched to ${usingTemp ? 'temporary' : 'actual'} data`);
	}
	refreshAll();
}

function saveData() {
	if (usingTemp) {
    console.log('Save operation skipped - using temporary data');
    return;
	 }
	Object.keys(actualData)
	.forEach(key => {
		if (key !== 'activeApplicationId') {
			localStorage.setItem(key, JSON.stringify(actualData[key]));
		} else {
			localStorage.setItem(key, actualData[key] || '');
		}
	});
}

// get ID functions
function getNextPersonId() { return Math.max(10000, ...(data.people.map(p => p.id) || [9999])) + 1; }
function getNextProviderId() { return Math.max(100001, ...(data.providers.map(p => p.id) || [100000])) + 1; }
function getNextApplicationId() { return Math.max(2003000000, ...(data.applications.map(a => a.id) || [2002999999])) + 1; }
function getNextActivityId() { return Math.max(1, ...(data.activities.map(a => a.id) || [0])) + 1; }
function getNextScheduleId() { return Math.max(1, ...(data.schedules.map(s => s.id) || [0])) + 1; }
function getNextResultId() { return Math.max(70000, ...(actualData.savedResults.map(r => r.id) || [0])) + 1; } // all results are only stored in actual data

let tempResult = { id: 0,
					appid: 0,
					startDate: new Date().toLocaleDateString('en-CA'),
					isPrimary: true,
					saveDate: new Date().toLocaleDateString('en-CA')
				};
let tempResultLines = [];
let tempShortSchedules = [];
let activeResultId = null;
let verboseReporting = true; // set default to false later

// end of global data 

// remove all data from localStorage
function removeAllStoredData()
{
if(!confirm('Are you sure? This will delete all stored data for this applcation.'))
{
	return;
}
	data.people= [];
	data.providers = [];
	data.applications = [];
	data.householdMembers = [];
	data.activities = [];
	data.providerLinks = [];
	data.schedules = [];
	data.savedResults = [];
	data.resultLines = [];
	data.shortSchedules = [];
	data.activeApplicationId = null;
	
	tempResult = { id: 0,
					appid: 0,
					startDate: new Date().toLocaleDateString('en-CA'),
					isPrimary: true,
					saveDate: new Date().toLocaleDateString('en-CA')
				};
	tempResultLines = [];
	tempShortSchedules = [];
	activeResultId = null;
	
	saveData();
	refreshAll();
}

function clearTempData()
{
	myTempData = {
	people: [],
	providers: [],
	applications: [],
	householdMembers: [],
	activities: [],
	providerLinks: [],
	schedules: [],
	savedResults: [],
	resultLines: [],
	shortSchedules: [],
	activeApplicationId:  null };
}
		
// toggle verbose reporting, weird issue using ternary operator or condensing this at all
function toggleVerboseReporting()
{
	verboseReporting = document.getElementById("repCheckbox").checked;
	if(verboseReporting)
	{ console.log('verbose reporting turned on.'); }
	else
	{ console.log('verbose reporting turned off.'); }
}

function showTab(tabName) 
{
	if(selectedScheduleId != null)
	{
		const refSchedule = data.schedules.find(s => s.id === selectedScheduleId);
		if(refSchedule)
		{
			if(JSON.stringify(myTempSchedule.weeks) != JSON.stringify(refSchedule.weeks))
			{
				if (!confirm('There are unsaved changes to the current schedule, are you sure you want to continue?'))
				{
					return;
				}
				else
				{
					selectedScheduleId = null;
					myTempSchedule = createTempEmptySchedule('A');
				}
			}
		}
	}


	document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
	document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
	
	document.getElementById(tabName).classList.add('active');
	event.target.classList.add('active');
	
	// Refresh content when switching tabs
	switch(tabName) {
		case 'people': refreshPeopleList(); break;
		case 'providers': refreshProvidersList(); break;
		case 'applications': refreshApplicationsList(); break;
		case 'household': refreshHouseholdForm(); refreshHouseholdList(); break;
		case 'activities': refreshActivityForm(); refreshActivitiesList(); break;
		case 'provider-links': refreshProviderLinkForm(); refreshProviderLinksList(); break;
		case 'schedules': refreshScheduleSelector(); break;
		case 'calculation': refreshCalculationForm(); break;
		case 'savedResults': refreshSavedResults(); break;
	}
}

function refreshSavedResults()
{
	const form = document.getElementById('savedResultsForm');
	
	if (usingTemp) {
		form.innerHTML = '<p>You are currently in a loaded state.</p>';
		document.getElementById('selectedCareResult').innerHTML = `<p>No other saved results can be accessed while in a loaded state.</p>`;
		return;
	}
	
	if (!data.activeApplicationId) {
		form.innerHTML = '<p>Please select an active application first.</p>';
		return;
	}
	const currResult = data.savedResults.find(r => r.appid === Number(data.activeApplicationId) && r.isPrimary === true);
	if (!currResult){
		form.innerHTML = '<p>There are no saved results for the selected applcation.</p>';
		return;
	}
	form.innerHTML = '';
	activeResultId = currResult.id;
	let addHTML = `<p>Active Application: ${data.activeApplicationId}</p>`;
	
	addHTML = addHTML + `<label for="results">Choose a care Result:</label><select id="careResult" onchange="updateResultSection()"><option value="${currResult.id}">${currResult.id} - Current Result - Saved: ${currResult.saveDate}</option>`;
	data.savedResults.forEach(l => {
		if(l.appid === Number(currResult.appid) && l.isPrimary === false && l.id !== currResult.id)
		{
			addHTML = addHTML + `<option value="${l.id}">${l.id} - Previous Result - Saved: ${l.saveDate}</option>`;
		}
		});
	addHTML += `</select>`;
	
	// add date input field and recalculate button that allows recalculation of the currently selected result using the specified date
	// add button to 'load' the selected result for modification, myTempData is built using data from result, then toggle data from actual to temp
	addHTML+= `<p><label>New Care Start Date:</label><input type="date" id="reCalcStartDate"></p>
		<button onclick="recalculateStoredResult()" style="background: #28a745; font-size: 16px; padding: 15px 30px;">Recalculate Care</button>
		<button onclick="loadSavedResultState()" style="background: #dc3545; font-size: 16px; padding: 15px 30px;">Reload Stored Result State</button></p>`;
		
	
	form.innerHTML += addHTML;
	updateResultSection();
}
		
// Should include all the data from shortSchedules along with actual formatted data for each resultLine
function updateResultSection()
{
	const result = document.getElementById('selectedCareResult');
	const resultID = document.getElementById('careResult').value;
	activeResultId = resultID;
	result.innerHTML = '';
	
	if(!activeResultId){
		result.innerHTML = '<p>No Result yet selected.</p>';
		return;
	}
	const myResult = data.savedResults.find(r => r.id === Number(activeResultId));
	
	//myResult.startDate
	
	// populate the result section with the authorization information from the selected saved result.
	let newHTML = `<p>${myResult.isPrimary ? 'Current' : 'Previous'} care results for application ${data.activeApplicationId} calculated on ${myResult.saveDate} for care starting ${myResult.startDate} based on the following information:</p>`;
	// Display case data captured at the time of the result from shortSchedules.
	// Activity Schedules first
	// Now uses compressedStringToSchedule instead of parseCondensedScheduleString
	data.shortSchedules.filter(s => s.did === myResult.id && s.type === 'A').forEach(a => {newHTML += `<p>${a.exp}: ${scheduleToUserFriendlyString(compressedStringToSchedule(a.sch))}</p>`;});
	// Then Provider-Child Link Schedules
	data.shortSchedules.filter(s => s.did === myResult.id && s.type === 'P').forEach(a => {newHTML += `<p>${a.exp}: ${scheduleToUserFriendlyString(compressedStringToSchedule(a.sch))}</p>`;});
	
	// display saved results, formatting should be similar to initial report formatting
	newHTML += '<div id="careResultLine"><h5>Resulting Care Results:</h5><ul>';
	// Then display the care results one at a time, should be formatted similarly to the initial results display
	// first display normal lines
		data.resultLines.filter(f => f.rid === Number(resultID) && f.isSummer === false).sort((a, b) => a.line - b.line).forEach(r => { 
					let mySvcCode = getSvcCodeObj(r.authType, myResult.startDate);
					let svcDisp = '[' + r.xCode + mySvcCode.svcCode + '] ' + mySvcCode.desc;
					
					newHTML += `<li>Authorize a ${svcDisp} care line, ${r.units.hr > 0 ? r.units.hr + ' hrs ' : ' ' + r.numUnits + ' unit(s) '} at ${Number(r.rate).toLocaleString('en-US', {style: 'currency', currency: 'USD'})}
						per unit totaling ${Number(r.ttl).toLocaleString('en-US', {style: 'currency', currency: 'USD'})}, for child ${r.clID} to provider #${r.prrID}`;
						if (r.region === 'A')
						{
							newHTML += ` based on region ${r.region} rates.`;
						}
						else
						{
							newHTML += `.`;
						}
						// add summary of units indented
						if(r.exp && (r.units.fd + r.units.hd + r.units.pd + r.excess > 0))
						{
							newHTML += ' Based on the following:<ul><li>';
							if(r.units.fd > 0) {newHTML += ` ${r.units.fd} full days. `;}
							if(r.units.pd > 0) {newHTML += ` ${r.units.pd} partial days. `;}
							if(r.units.hd > 0) {newHTML += ` ${r.units.hd} half days. `;}
							if(r.excess > 0) {newHTML += ` ${Number(r.excess).toLocaleString('en-US', {style: 'currency', currency: 'USD'})} in excess care. `;}
							newHTML += '</li></ul></li>';
						}
						else
						{
							newHTML += '</li>';
						}
						});
		newHTML += '</ul></div>';		
	// next display summer lines
	if(data.resultLines.filter(f => f.rid === Number(resultID) && f.isSummer === true).length > 0)
	{
		newHTML += '<div id="careResultLine"><h5>Care for Summer:</h5><ul>';
		data.resultLines.filter(f => f.rid === Number(resultID) && f.isSummer === true).sort((a, b) => a.line - b.line).forEach(r => { 
					let mySvcCode = getSvcCodeObj(r.authType, myResult.startDate);
					let svcDisp = '[' + r.xCode + mySvcCode.svcCode + '] ' + mySvcCode.desc;
					
					newHTML += `<li>Authorize a ${svcDisp} care line, ${r.units.hr > 0 ? r.units.hr + ' hrs ' : ' ' + r.numUnits + ' unit(s) '} at ${Number(r.rate).toLocaleString('en-US', {style: 'currency', currency: 'USD'})}
						per unit totaling ${Number(r.ttl).toLocaleString('en-US', {style: 'currency', currency: 'USD'})}, for child ${r.clID} to provider #${r.prrID}`;
						if (r.region === 'A')
						{
							newHTML += ` based on region ${r.region} rates.`;
						}
						else
						{
							newHTML += `.`;
						}
						// add summary of units indented
						if(r.exp && (r.units.fd + r.units.hd + r.units.pd + r.excess > 0))
						{
							newHTML += ' Based on the following:<ul><li>';
							if(r.units.fd > 0) {newHTML += ` ${r.units.fd} full days. `;}
							if(r.units.pd > 0) {newHTML += ` ${r.units.pd} partial days. `;}
							if(r.units.hd > 0) {newHTML += ` ${r.units.hd} half days. `;}
							if(r.excess > 0) {newHTML += ` ${Number(r.excess).toLocaleString('en-US', {style: 'currency', currency: 'USD'})} in excess care. `;}
							newHTML += '</li></ul></li>';
						}
						else
						{
							newHTML += '</li>';
						}
						});		
		newHTML += '</ul></div>';								
	}
	else{
		newHTML += '<div id="careResultLine"><h5>No Changes Required for the household for Summer</h5></div>';
	}
	result.innerHTML = newHTML;
	// clear any calculation results in the recalculation section
	document.getElementById('recalculationSection').innerHTML = '';
}

function formatTime(minutes) 
{
	// Handle special case where 1440 should display as 12:00 AM (end of day)
	if (minutes === 1440) minutes = 0;
	
	const hours = Math.floor(minutes / 60);
	const mins = minutes % 60;
	const period = hours >= 12 ? 'PM' : 'AM';
	const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
	return `${displayHours}:${mins.toString().padStart(2, '0')} ${period}`;
}

function parseTime(timeString) 
{
	const match = timeString.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
	if (!match) return null;
	
	let hours = parseInt(match[1]);
	const minutes = parseInt(match[2]);
	const period = match[3].toUpperCase();
	
	if (hours === 12 && period === 'AM') hours = 0;
	if (hours !== 12 && period === 'PM') hours += 12;
	
	const totalMinutes = hours * 60 + minutes;
	
	// Special case: 12:00 AM should be treated as 1440 (end of day) when used as end time
	// This will be handled in the calling function by context
	return totalMinutes;
}

// People functions
function addPerson() 
{
	const name = document.getElementById('personName').value.trim();
	const birthdate = document.getElementById('personBirthdate').value;
	
	// Clear previous errors
	document.getElementById('personNameError').textContent = '';
	document.getElementById('personBirthdateError').textContent = '';
	
	let hasError = false;
	
	if (!name) {
		document.getElementById('personNameError').textContent = 'Name is required';
		hasError = true;
	}
	
	if (!birthdate) {
		document.getElementById('personBirthdateError').textContent = 'Birthdate is required';
		hasError = true;
	} else if (new Date(birthdate) > new Date()) {
		document.getElementById('personBirthdateError').textContent = 'Birthdate cannot be in the future';
		hasError = true;
	}
	
	if (hasError) return;
	
	const person = {
		id: getNextPersonId(),
		name: name,
		birthdate: birthdate
	};
	
	data.people.push(person);
	saveData();
	
	document.getElementById('personName').value = '';
	document.getElementById('personBirthdate').value = '';
	
	refreshPeopleList();
	refreshApplicationsList(); // Update head of household dropdown
}

function deletePerson(id) 
{
	if (confirm('Are you sure you want to delete this person?')) {
		data.people = data.people.filter(p => p.id !== id);
		data.applications = data.applications.filter(a => a.headOfHouseholdId !== id);
		data.householdMembers = data.householdMembers.filter(h => h.personId !== id);
		data.activities.filter(a => a.personId == id).forEach(e => {
			if(selectedScheduleId === e.scheduleId)
			{
				selectedScheduleId = null;
			}
			data.schedules = data.schedules.filter(s => s.id !== e.scheduleId);
			});
		data.activities = data.activities.filter(a => a.personId !== id);
		data.providerLinks.filter(p => p.personId == id).forEach(l => {
			if(selectedScheduleId === l.scheduleId)
			{
				selectedScheduleId = null;
			}
			data.schedules = data.schedules.filter(s => s.id !== l.scheduleId);
			});
		data.providerLinks = data.providerLinks.filter(p => p.persionId !== id);
		if(data.activeApplicationId !== null)
		{
			if(!data.applications.find(a => Number(a.id) === Number(data.activeApplicationId)))
			{
				data.activeApplicationId = null;
			}
		}
		saveData();
		refreshAll();
	}
}

function refreshPeopleList() 
{
	const list = document.getElementById('peopleList');
	list.innerHTML = '';
	
	data.people.forEach(person => {
		const div = document.createElement('div');
		div.className = 'list-item';
		div.innerHTML = `
			<span>ID: ${person.id} - ${person.name} (Born: ${person.birthdate})</span>
			`; // <button class="danger" onclick="deletePerson(${person.id})">Delete</button>`;
		list.appendChild(div);
	});
	
	// Update head of household dropdown
	const select = document.getElementById('headOfHousehold');
	select.innerHTML = '<option value="">Select a person</option>';
	data.people.forEach(person => {
		const option = document.createElement('option');
		option.value = person.id;
		option.textContent = `${person.name} (ID: ${person.id})`;
		select.appendChild(option);
	});
}

// Provider functions
function addProvider() 
{
	const name = document.getElementById('providerName').value.trim();
	const type = document.getElementById('providerType').value;
const region = document.getElementById('providerRegion').value;
	
	if (!name) {
		alert('Provider name is required');
		console.log('Provider name is required');
		return;
	}
	
	const provider = {
		id: getNextProviderId(),
		name: name,
		type: type,
		region: region
	};
	
	data.providers.push(provider);
	saveData();
	
	document.getElementById('providerName').value = '';
	
	refreshProvidersList();
}

function toggleLocationOfCare()
{
	const prrLink = document.getElementById('linkProvider');
	const prrNum = Number(prrLink.value);
	const prr = data.providers.find(p => p.id === prrNum);
	const locCare = document.getElementById('locationCare');
	
	if (prr.type === 'F') {
		locCare.disabled=false;
	}
	else{
		locCare.value = 'P';
		locCare.disabled=true;
	}
}

function deleteProvider(id)
{
	if (confirm('Are you sure you want to delete this provider?')) {
		data.providers = data.providers.filter(p => p.id !== id);
		data.providerLinks.filter(p => p.providerId == id).forEach(l => {
			if(selectedScheduleId === l.scheduleId)
			{
				selectedScheduleId = null;
			}
			data.schedules = data.schedules.filter(s => s.id !== l.scheduleId);
			});
		data.providerLinks = data.providerLinks.filter(p => p.providerId !== id);
		
		saveData();
		refreshAll();
	}
}

function refreshProvidersList() 
{
	const list = document.getElementById('providersList');
	list.innerHTML = '';
	
	data.providers.forEach(provider => {
		const div = document.createElement('div');
		div.className = 'list-item';
		const typeName = provider.type === 'C' ? 'Center' : provider.type === 'F' ? 'FFN' : 'LFH';
		div.innerHTML = `
			<span>ID: ${provider.id} - ${provider.name} (${typeName})</span>
			`; // <button class="danger" onclick="deleteProvider(${provider.id})">Delete</button>`;
		list.appendChild(div);
	});
}

// Application functions
function addApplication() 
{
	const headOfHouseholdId = parseInt(document.getElementById('headOfHousehold').value);
	
	if (!headOfHouseholdId) {
		alert('Please select a head of household');
		console.log('Please select a head of household');
		return;
	}
	if(usingTemp)
	{
		alert('Applications can not be created in a reloaded state.');
		console.log('Applications can not be created in a reloaded state.');
		return;
	}
	
	const application = {
		id: getNextApplicationId(),
		headOfHouseholdId: headOfHouseholdId
	};
	
	data.applications.push(application);
	
	if(data.applications.length === 1)
	{
		data.activeApplicationId = application.id;
	}
	
	saveData();
	
	document.getElementById('headOfHousehold').value = '';
	
	refreshApplicationsList();
}

function deleteApplication(id) 
{
	if (confirm('Are you sure you want to delete this application?')) 
	{
		data.applications = data.applications.filter(a => a.id !== id);
		// Clean up related data
		const myHouseholdMembers = data.householdMembers.filter(m => m.applicationId == id);
		// Remove the schedules for all the activities and providerLinks
		myHouseholdMembers.forEach(m => {
			data.activities.filter(a => a.personId == m.personId && m.applicationId == id).forEach(e => {
			if(selectedScheduleId === e.scheduleId)
			{
				selectedScheduleId = null;
			}
			data.schedules = data.schedules.filter(s => s.id !== e.scheduleId);
			});
			data.providerLinks.filter(p => p.personId == m.personId && m.applicationId == id).forEach(l => {
			if(selectedScheduleId === l.scheduleId)
			{
				selectedScheduleId = null;
			}
			data.schedules = data.schedules.filter(s => s.id !== l.scheduleId);
			});
		});
		
		data.householdMembers = data.householdMembers.filter(h => h.applicationId !== id);
		data.activities = data.activities.filter(a => a.applicationId !== id);
		data.providerLinks = data.providerLinks.filter(p => p.applicationId !== id);
		
		if (data.activeApplicationId == id) 
		{
			data.activeApplicationId = null;
		}
		selectedScheduleId = null;
		saveData();
		refreshApplicationsList();
		refreshHouseholdForm();
		refreshActivityForm();
		refreshProviderLinkForm();
		refreshSavedResults();
	}
}

function setActiveApplication(id) 
{
	data.activeApplicationId = id;
	selectedScheduleId = null;
	saveData();
	refreshApplicationsList();
	refreshHouseholdForm();
	refreshActivityForm();
	refreshProviderLinkForm();
	refreshSavedResults();
}

function refreshApplicationsList() 
{
	const list = document.getElementById('applicationsList');
	list.innerHTML = '';
	
	if(data.applications.length === 1)
	{
		data.activeApplicationId = data.applications[0].id;
	}
	
	data.applications.forEach(app => {
		const person = data.people.find(p => p.id === app.headOfHouseholdId);
		const div = document.createElement('div');
		div.className = 'list-item';
		if (data.activeApplicationId == app.id) {
			div.classList.add('active-app');
		}
		div.innerHTML = `
			<span>ID: ${app.id} - Head: ${person ? person.name : 'Unknown'}</span>
			<div>
				<button onclick="setActiveApplication(${app.id})">Set Active</button> 
				</div>`; // <button class="danger" onclick="deleteApplication(${app.id})">Delete</button></div>`;
		list.appendChild(div);
	});
	
	// Update active application display
	const activeDiv = document.getElementById('activeApplication');
	if (data.activeApplicationId) {
		const app = data.applications.find(a => a.id == data.activeApplicationId);
		const person = app ? data.people.find(p => p.id === app.headOfHouseholdId) : null;
		activeDiv.innerHTML = `Active: Application ${data.activeApplicationId} - Head: ${person ? person.name : 'Unknown'}`;
	} else {
		activeDiv.innerHTML = 'No active application selected';
	}
}

// Household functions
function refreshHouseholdForm() 
{
	const form = document.getElementById('householdForm');
	
	if (!data.activeApplicationId) {
		form.innerHTML = '<p>Please select an active application first.</p>';
		return;
	}
	
	const app = data.applications.find(a => a.id == data.activeApplicationId);
	if (!app) {
		form.innerHTML = '<p>Active application not found.</p>';
		return;
	}
	
	// Get available people (exclude head of household and already added members)
	const existingMemberIds = data.householdMembers
		.filter(h => h.applicationId == data.activeApplicationId)
		.map(h => h.personId);
	existingMemberIds.push(app.headOfHouseholdId);
	
	const availablePeople = data.people.filter(p => !existingMemberIds.includes(p.id));
	
	form.innerHTML = `
		<div class="form-group">
			<label>Person:</label>
			<select id="householdPerson">
				<option value="">Select a person</option>
				${availablePeople.map(p => `<option value="${p.id}">${p.name} (ID: ${p.id})</option>`).join('')}
			</select>
		</div>
		<div class="form-group">
			<label>Member Type:</label>
			<select id="householdMemberType">
				<option value="C">Child (C)</option>
				<option value="A">Adult (A)</option>
			</select>
		</div>
		<div class="form-group">
			<label>Included:</label>
			<select id="householdIncluded">
				<option value="Y">Yes (Y)</option>
				<option value="N">No (N)</option>
			</select>
		</div>
		<button onclick="addHouseholdMember()">Add Household Member</button>
	`;
}

function addHouseholdMember() 
{
	const personId = parseInt(document.getElementById('householdPerson').value);
	const memberType = document.getElementById('householdMemberType').value;
	const included = document.getElementById('householdIncluded').value;
	
	if (!personId) {
		alert('Please select a person');
		console.log('Please select a person');
		return;
	}
	
	const householdMember = {
		applicationId: parseInt(data.activeApplicationId),
		personId: personId,
		memberType: memberType,
		included: included
	};
	
	data.householdMembers.push(householdMember);
	saveData();
	
	refreshHouseholdForm();
	refreshHouseholdList();
	refreshActivityForm();
	refreshProviderLinkForm();
}

function toggleIncluded(applicationId, personId) 
{
	const member = data.householdMembers.find(h => h.applicationId === applicationId && h.personId === personId);
	member.included = (member.included === 'Y' ? 'N' : 'Y');
	saveData();
	refreshHouseholdForm();
	refreshHouseholdList();
}

function deleteHouseholdMember(applicationId, personId) 
{
	if (confirm('Are you sure you want to remove this household member?')) 
	{
		data.householdMembers = data.householdMembers.filter(h => 
			!(h.applicationId === applicationId && h.personId === personId));
		data.activities.filter(a => a.personId == personId && a.applicationId == applicationId).forEach(e => {
			if(selectedScheduleId === e.scheduleId)
			{
				selectedScheduleId = null;
			}
			data.schedules = data.schedules.filter(s => s.id !== e.scheduleId);
			});
			data.providerLinks.filter(p => p.personId == personId && p.applicationId == applicationId).forEach(l => {
			if(selectedScheduleId === l.scheduleId)
			{
				selectedScheduleId = null;
			}
			data.schedules = data.schedules.filter(s => s.id !== l.scheduleId);
			});
		
		saveData();
		refreshHouseholdForm();
		refreshHouseholdList();
		refreshActivityForm();
		refreshProviderLinkForm();
		refreshSavedResults();
	}
}

function refreshHouseholdList() 
{
	const list = document.getElementById('householdList');
	list.innerHTML = '';
	
	if (!data.activeApplicationId) {
		list.innerHTML = '<p>No active application selected.</p>';
		return;
	}
	
	const members = data.householdMembers.filter(h => h.applicationId == data.activeApplicationId);
	
	members.forEach(member => {
		const person = data.people.find(p => p.id === member.personId);
		const div = document.createElement('div');
		div.className = 'list-item';
		const memberTypeName = member.memberType === 'C' ? 'Child' : 'Adult';
		const includedName = member.included === 'Y' ? 'Yes' : 'No';
		div.innerHTML = `<span>${person ? person.name : 'Unknown'} (${memberTypeName}, Included: ${includedName})</span><div class="buttonRow">
		<button class="saveButton" onclick="toggleIncluded(${member.applicationId}, ${member.personId})">Toggle Included</button>
		<button class="danger" onclick="deleteHouseholdMember(${member.applicationId}, ${member.personId})">Remove</button></div>`;

		list.appendChild(div);
	});
	
	if (members.length === 0) {
		list.innerHTML = '<p>No household members added yet.</p>';
	}
}

// Activity functions
function refreshActivityForm() 
{
	const form = document.getElementById('activityForm');
	
	if (!data.activeApplicationId) {
		form.innerHTML = '<p>Please select an active application first.</p>';
		return;
	}
	
	const app = data.applications.find(a => a.id == data.activeApplicationId);
	if (!app) {
		form.innerHTML = '<p>Active application not found.</p>';
		return;
	}
	
	// Get eligible people (head of household + included household members)
	const eligiblePeople = [];
	
	// Add head of household
	const headPerson = data.people.find(p => p.id === app.headOfHouseholdId);
	if (headPerson) {
		eligiblePeople.push({...headPerson, isHead: true, memberType: 'A'});
	}
	
	// Add included household members
	const includedMembers = data.householdMembers.filter(h => 
		h.applicationId == data.activeApplicationId && h.included === 'Y');
	
	includedMembers.forEach(member => {
		const person = data.people.find(p => p.id === member.personId);
		if (person) {
			eligiblePeople.push({...person, isHead: false, memberType: member.memberType});
		}
	});
	
	form.innerHTML = `
		<div class="form-group">
			<label>Person:</label>
			<select id="activityPerson" onchange="updateActivityTypeOptions()">
				<option value="">Select a person</option>
				${eligiblePeople.map(p => `<option value="${p.id}" data-member-type="${p.memberType}">${p.name} (${p.isHead ? 'Head of Household' : p.memberType === 'A' ? 'Adult' : 'Child'})</option>`).join('')}
			</select>
		</div>
		<div class="form-group">
			<label>Activity Name:</label>
			<input type="text" id="activityName" placeholder="Enter activity name">
		</div>
		<div class="form-group">
			<label>Activity Type:</label>
			<select id="activityType">
				<option value="">Select activity type</option>
			</select>
		</div>
		<button onclick="addActivity()">Add Activity</button>
	`;
}

function updateActivityTypeOptions() 
{
	const personSelect = document.getElementById('activityPerson');
	const typeSelect = document.getElementById('activityType');
	const selectedOption = personSelect.options[personSelect.selectedIndex];
	
	typeSelect.innerHTML = '<option value="">Select activity type</option>';
	
	if (selectedOption && selectedOption.dataset.memberType) {
		const memberType = selectedOption.dataset.memberType;
		
		if (memberType === 'A') { // Adult or Head of Household
			typeSelect.innerHTML += '<option value="Activity">Activity</option>';
			typeSelect.innerHTML += '<option value="Sleep">Sleep</option>';
		} else if (memberType === 'C') { // Child
			if(data.activities.filter(a => a.applicationId === Number(data.activeApplicationId) && ((a.type === 'School') || (a.type === 'Preschool'))).length === 0)
			{
				typeSelect.innerHTML += '<option value="School">School</option>';
				typeSelect.innerHTML += '<option value="Preschool">Preschool</option>';
			}
			if(data.activities.filter(a => a.applicationId === Number(data.activeApplicationId) && a.type === 'Non care').length === 0)
			{
				typeSelect.innerHTML += '<option value="Non care">Non Care</option>';
			}
		}
	}
}

function addActivity() 
{
	const personId = parseInt(document.getElementById('activityPerson').value);
	const name = document.getElementById('activityName').value.trim();
	const type = document.getElementById('activityType').value;
	
	
	if (!personId || !name || !type) {
		alert('Please fill in all fields');
		console.log('Please fill in all fields');
		return;
	}
	
	// Determine schedule type based on activity type
	let scheduleType;
	switch(type) {
		case 'Activity': scheduleType = 'A'; break;
		case 'Sleep': scheduleType = 'L'; break;
		case 'School': scheduleType = 'S'; break;
		case 'Preschool': scheduleType = 'P'; break;
		case 'Non care': scheduleType = 'N'; break;
		default: scheduleType = 'A';
	}
	
	// Create schedule
	const schedule = createEmptySchedule(scheduleType);
	const defaultInc = data.householdMembers.find(h => h.applicationId == Number(data.activeApplicationId) && h.memberType === 'A' && h.included === 'N' && h.personId === personId) ? false : true;
	
	
	const activity = {
		id: getNextActivityId(),
		applicationId: parseInt(data.activeApplicationId),
		personId: personId,
		name: name,
		type: type,
		careNeeded: defaultInc,
		scheduleId: schedule.id
	};
	
	data.activities.push(activity);
	saveData();
	
	document.getElementById('activityPerson').value = '';
	document.getElementById('activityName').value = '';
	document.getElementById('activityType').value = '';
	
	refreshActivitiesList();
	refreshScheduleSelector();
}

function toggleCareNeeded(appId, id)
{
	const myAct = data.activities.find(a => a.id == id && a.applicationId == appId);
	
	if(!myAct)
	{
		console.log('Error! Activity [${id}] not found.')
		return;
	}
	myAct.careNeeded = !myAct.careNeeded;
	saveData();
	refreshActivitiesList() 
}

function deleteActivity(id) 
{
	if (confirm('Are you sure you want to delete this activity?')) {
		const activity = data.activities.find(a => a.id === id);
		if (activity) {
			// Remove associated schedule
			data.schedules = data.schedules.filter(s => s.id !== activity.scheduleId);
		}
		if(selectedScheduleId === activity.scheduleId)
		{
			selectedScheduleId = null;
		}
		data.activities = data.activities.filter(a => a.id !== id);
		saveData();
		refreshActivitiesList();
		updateActivityTypeOptions()
		refreshScheduleSelector();
	}
}

function refreshActivitiesList() 
{
	const list = document.getElementById('activitiesList');
	list.innerHTML = '';
	
	if (!data.activeApplicationId) {
		list.innerHTML = '<p>No active application selected.</p>';
		return;
	}
	
	const activities = data.activities.filter(a => a.applicationId == data.activeApplicationId);
	const excludedMembers = data.householdMembers.filter(h => h.applicationId == data.activeApplicationId && ((h.memberType === 'C') || (h.included === 'N')));
	
	activities.forEach(activity => {
		const person = data.people.find(p => p.id === activity.personId);
		const div = document.createElement('div');
		let careStr = activity.careNeeded ? '' : '- No Care Needed';
		div.className = 'list-item';
		let addHTML = `<span>${activity.name} - ${person ? person.name : 'Unknown'} (${activity.type} ${careStr})</span><div class="buttonRow">`;
		if(!excludedMembers.find(e => e.personId === activity.personId))
		{
			addHTML += `<button class="saveButton" onclick="toggleCareNeeded(${activity.applicationId},${activity.id})">Toggle Care Needed</button>`;
		}
		addHTML += `<button class="danger" onclick="deleteActivity(${activity.id})">Delete</button></div>`;
		
		div.innerHTML = addHTML;
		list.appendChild(div);
	});
	
	if (activities.length === 0) {
		list.innerHTML = '<p>No activities added yet.</p>';
	}
}

// Provider Link functions
function refreshProviderLinkForm() 
{
	const form = document.getElementById('providerLinkForm');
	
	if (!data.activeApplicationId) {
		form.innerHTML = '<p>Please select an active application first.</p>';
		return;
	}
	
	// Get eligible children (included household members who are children)
	const eligibleChildren = [];
	const includedMembers = data.householdMembers.filter(h => 
		h.applicationId == data.activeApplicationId && h.included === 'Y' && h.memberType === 'C');
	
	includedMembers.forEach(member => {
		const person = data.people.find(p => p.id === member.personId);
		if (person) {
			eligibleChildren.push(person);
		}
	});
	
	if (eligibleChildren.length === 0) {
		form.innerHTML = '<p>No eligible children in the current application.</p>';
		return;
	}
	
	form.innerHTML = `
		<div class="form-group">
			<label>Provider:</label>
			<select id="linkProvider" onchange=toggleLocationOfCare()>
				<option value="">Select a provider</option>
				${data.providers.map(p => `<option value="${p.id}">${p.name} (${p.type})</option>`).join('')}
			</select>
		</div>
		<div class="form-group">
			<label>Location of Care:</label>
			<select id = "locationCare" disabled=true>
				<option value="P">With Provider</option>
				<option value="C">Clients Home</option>
				<option value="M">Mutual Home</option>
			</select>
		</div>
		<div class="form-group">
			<label>Child:</label>
			<select id="linkChild">
				<option value="">Select a child</option>
				${eligibleChildren.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
			</select>
		</div>
		<button onclick="addProviderLink()">Add Provider-Child Link</button>
	`;
}

function addProviderLink() 
{
	const providerId = parseInt(document.getElementById('linkProvider').value);
	const personId = parseInt(document.getElementById('linkChild').value);
	const prr = data.providers.find(p => p.id === providerId);
	const subLoc = (prr.type === 'F' ? document.getElementById('locationCare').value : 'P');
	const locCare = (subLoc === 'M' ? 'C' : subLoc);
	
	if (!providerId || !personId) {
		alert('Please select both provider and child');
		console.log('Please select both provider and child');
		return;
	}
	
	// Check if link already exists
	const existingLink = data.providerLinks.find(l => 
		l.applicationId == data.activeApplicationId && 
		l.providerId === providerId && 
		l.personId === personId &&
		l.locCare === locCare);
	
	if (existingLink) {
		alert('This provider-child link already exists');
		console.log('This provider-child link already exists');
		return;
	}
	
	// Check if this is the first provider for this child
	const existingLinksForChild = data.providerLinks.filter(l => 
		l.applicationId == data.activeApplicationId && 
		l.personId === personId);
	
	const isPrimary = existingLinksForChild.length === 0 ? 'Y' : 'N';
	
	// Create schedule for the link
	const schedule = createEmptySchedule('R');
	
	const providerLink = {
		providerId: providerId,
		applicationId: parseInt(data.activeApplicationId),
		personId: personId,
		scheduleId: schedule.id,
		primary: isPrimary,
		locCare: locCare,
		subLoc: subLoc
	};
	
	data.providerLinks.push(providerLink);
	saveData();
	
	document.getElementById('linkProvider').value = '';
	document.getElementById('linkChild').value = '';
	
	refreshProviderLinksList();
	refreshScheduleSelector();
}

function setPrimaryProvider(providerId, applicationId, personId, locCare) 
{
	// Set all other provider links for this child to non-primary
	data.providerLinks.forEach(link => {
		if (link.applicationId === applicationId && link.personId === personId) {
			link.primary = 'N';
		}
	});
	
	// Set the selected link as primary
	const targetLink = data.providerLinks.find(l => 
		l.providerId === providerId && 
		l.applicationId === applicationId && 
		l.personId === personId && l.locCare === locCare);
	
	if (targetLink) {
		targetLink.primary = 'Y';
		saveData();
		refreshProviderLinksList();
	}
}

function deleteProviderLink(providerId, applicationId, personId, locCare) 
{
	if (confirm('Are you sure you want to delete this provider-child link?')) {
		const link = data.providerLinks.find(l => 
			l.providerId === providerId && 
			l.applicationId === applicationId && 
			l.personId === personId && l.locCare === locCare);
		
		if (link) {
			// Remove associated schedule
			data.schedules = data.schedules.filter(s => s.id !== link.scheduleId);
			if(selectedScheduleId === link.scheduleId)
			{
				selectedScheduleId = null;
			}
			
			// If this was the primary provider, make another one primary if available
			if (link.primary === 'Y') {
				const otherLinks = data.providerLinks.filter(l => 
					l.applicationId === applicationId && 
					l.personId === personId && 
					!(l.providerId === providerId && l.applicationId === applicationId && l.personId === personId && l.locCare === locCare));
				
				if (otherLinks.length > 0) {
					otherLinks[0].primary = 'Y';
				}
			}
		}
		
		data.providerLinks = data.providerLinks.filter(l => 
			!(l.providerId === providerId && 
			  l.applicationId === applicationId && 
			  l.personId === personId && l.locCare === locCare));
			  
		saveData();
		refreshProviderLinksList();
		refreshScheduleSelector();
	}
}

function refreshProviderLinksList() 
{
	const list = document.getElementById('providerLinksList');
	list.innerHTML = '';
	
	if (!data.activeApplicationId) {
		list.innerHTML = '<p>No active application selected.</p>';
		return;
	}
	
	const links = data.providerLinks.filter(l => l.applicationId == data.activeApplicationId);
	
	links.forEach(link => {
		const provider = data.providers.find(p => p.id === link.providerId);
		const person = data.people.find(p => p.id === link.personId);
		const div = document.createElement('div');
		div.className = 'list-item';
		
		const primaryText = link.primary === 'Y' ? ' (PRIMARY)' : '';
		const primaryButton = link.primary === 'N' ? 
			`<button onclick="setPrimaryProvider(${link.providerId}, ${link.applicationId}, ${link.personId}, '${link.locCare}')">Set as Primary</button>` : '';
		
		div.innerHTML = `
			<span>${provider ? provider.name : 'Unknown Provider'} - ${person ? person.name : 'Unknown Child'} ${provider.type==='F' ? (link.locCare === 'C' ? ' [clients home' + (link.subLoc === 'M' ? ' (Mutual Home)]':']') : ' [with provider]'):''}${primaryText}</span>
			<div>
				${primaryButton}
				<button class="danger" onclick="deleteProviderLink(${link.providerId}, ${link.applicationId}, ${link.personId}, '${link.locCare}')">Delete</button>
			</div>
		`;
		list.appendChild(div);
	});
	
	if (links.length === 0) {
		list.innerHTML = '<p>No provider-child links added yet.</p>';
	}
}

// Schedule utility functions for calculations

// Get the greatest common divisor of two numbers
function gcd(a, b) 
{
	while (b !== 0) {
		let temp = b;
		b = a % b;
		a = temp;
	}
	return a;
}

// Get the least common multiple of two numbers
function lcm(a, b) 
{
	return (a * b) / gcd(a, b);
}
        
// Get the number of weeks in a schedule
function getScheduleWeekCount(schedule) 
{
	return Math.max(...Object.keys(schedule.weeks).map(Number));
}

// Check if two schedules have overlapping periods
function schedulesOverlap(schedule1, schedule2) 
{
	const weeks1 = getScheduleWeekCount(schedule1);
	const weeks2 = getScheduleWeekCount(schedule2);
	const totalWeeks = lcm(weeks1, weeks2);
	
	const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	
	// Check each week and day in the LCM period
	for (let week = 1; week <= totalWeeks; week++) {
		for (let day of days) {
			// Get periods for this week/day from both schedules
			const week1 = ((week - 1) % weeks1) + 1;
			const week2 = ((week - 1) % weeks2) + 1;
			
			const periods1 = schedule1.weeks[week1] ? schedule1.weeks[week1][day] || [] : [];
			const periods2 = schedule2.weeks[week2] ? schedule2.weeks[week2][day] || [] : [];
			
			// Check for overlaps between periods
			for (let p1 of periods1) {
				for (let p2 of periods2) {
					// Two periods overlap if one starts before the other ends
					if (p1.start < p2.end && p2.start < p1.end) {
						return true;
					}
				}
			}
		}
	}
	
	return false;
}
        
// Combine two schedules into one
function combineSchedules(schedule1, schedule2) 
{
	const weeks1 = getScheduleWeekCount(schedule1);
	const weeks2 = getScheduleWeekCount(schedule2);
	const totalWeeks = lcm(weeks1, weeks2);
	
	const combinedSchedule = {
		id: getNextTempScheduleId++,
		type: 'A',
		weeks: {}
	};
	
	const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	
	// Initialize all weeks
	for (let week = 1; week <= totalWeeks; week++) {
		combinedSchedule.weeks[week] = {};
		for (let day of days) {
			combinedSchedule.weeks[week][day] = [];
		}
	}
	
	// Process each week and day
	for (let week = 1; week <= totalWeeks; week++) {
		for (let day of days) {
			const week1 = ((week - 1) % weeks1) + 1;
			const week2 = ((week - 1) % weeks2) + 1;
			
			const periods1 = schedule1.weeks[week1] ? schedule1.weeks[week1][day] || [] : [];
			const periods2 = schedule2.weeks[week2] ? schedule2.weeks[week2][day] || [] : [];
			
			// Combine all periods and sort by start time
			const allPeriods = [...periods1, ...periods2].sort((a, b) => a.start - b.start);
			
			// Merge overlapping or adjacent periods
			const mergedPeriods = [];
			for (let period of allPeriods) {
				if (mergedPeriods.length === 0) {
					mergedPeriods.push({...period});
				} else {
					const lastPeriod = mergedPeriods[mergedPeriods.length - 1];
					
					// If periods overlap or are adjacent and same type, merge them
					if (lastPeriod.end >= period.start && lastPeriod.type === period.type) {
						lastPeriod.end = Math.max(lastPeriod.end, period.end);
					} else if (lastPeriod.end >= period.start) {
						// Overlapping but different types - handle priority (Sleep over Activity)
						if (period.type === 'L' || lastPeriod.type === 'L') {
							// Split periods to preserve sleep type
							if (lastPeriod.type === 'L') {
								// Current period is sleep, split incoming period
								if (period.start < lastPeriod.start) {
									mergedPeriods.splice(-1, 0, {
										start: period.start,
										end: lastPeriod.start,
										type: period.type
									});
								}
								if (period.end > lastPeriod.end) {
									mergedPeriods.push({
										start: lastPeriod.end,
										end: period.end,
										type: period.type
									});
								}
							} else {
								// Incoming period is sleep, adjust current and add sleep
								if (period.start > lastPeriod.start) {
									lastPeriod.end = period.start;
									mergedPeriods.push({...period});
								} else {
									mergedPeriods[mergedPeriods.length - 1] = {...period};
								}
								if (period.end < lastPeriod.end) {
									mergedPeriods.push({
										start: period.end,
										end: lastPeriod.end,
										type: lastPeriod.type
									});
								}
							}
						} else {
							// Both same non-sleep type, merge
							lastPeriod.end = Math.max(lastPeriod.end, period.end);
						}
					} else {
						mergedPeriods.push({...period});
					}
				}
			}
			
			combinedSchedule.weeks[week][day] = mergedPeriods;
		}
	}
	
	return combinedSchedule;
}
        
// Get overlap between two schedules
function getScheduleOverlap(schedule1, schedule2) 
{
	const weeks1 = getScheduleWeekCount(schedule1);
	const weeks2 = getScheduleWeekCount(schedule2);
	const totalWeeks = lcm(weeks1, weeks2);
	
	const overlapSchedule = {
		id: nextTempScheduleId++,
		type: 'A',
		weeks: {}
	};
	
	const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	
	// Initialize all weeks
	for (let week = 1; week <= totalWeeks; week++) {
		overlapSchedule.weeks[week] = {};
		for (let day of days) {
			overlapSchedule.weeks[week][day] = [];
		}
	}
	
	// Find overlaps for each week and day
	for (let week = 1; week <= totalWeeks; week++) {
		for (let day of days) {
			const week1 = ((week - 1) % weeks1) + 1;
			const week2 = ((week - 1) % weeks2) + 1;
			
			const periods1 = schedule1.weeks[week1] ? schedule1.weeks[week1][day] || [] : [];
			const periods2 = schedule2.weeks[week2] ? schedule2.weeks[week2][day] || [] : [];
			
			const overlaps = [];
			
			for (let p1 of periods1) {
				for (let p2 of periods2) {
					if (p1.start < p2.end && p2.start < p1.end) {
						const overlapStart = Math.max(p1.start, p2.start);
						const overlapEnd = Math.min(p1.end, p2.end);
						const overlapType = (p1.type === 'L' || p2.type === 'L') ? 'L' : 'A';
						
						overlaps.push({
							start: overlapStart,
							end: overlapEnd,
							type: overlapType
						});
					}
				}
			}
			
			// Merge adjacent overlaps of same type
			overlaps.sort((a, b) => a.start - b.start);
			const mergedOverlaps = [];
			for (let overlap of overlaps) {
				if (mergedOverlaps.length === 0) {
					mergedOverlaps.push(overlap);
				} else {
					const last = mergedOverlaps[mergedOverlaps.length - 1];
					if (last.end >= overlap.start && last.type === overlap.type) {
						last.end = Math.max(last.end, overlap.end);
					} else {
						mergedOverlaps.push(overlap);
					}
				}
			}
			
			overlapSchedule.weeks[week][day] = mergedOverlaps;
		}
	}
	
	return overlapSchedule;
}
        
// Subtract one schedule from another
function subtractSchedule(schedule1, schedule2) 
{
	const weeks1 = getScheduleWeekCount(schedule1);
	const weeks2 = getScheduleWeekCount(schedule2);
	const totalWeeks = lcm(weeks1, weeks2);
	
	const resultSchedule = {
		id: nextTempScheduleId++,
		type: schedule1.type,
		weeks: {}
	};
	
	const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	
	// Initialize all weeks
	for (let week = 1; week <= totalWeeks; week++) {
		resultSchedule.weeks[week] = {};
		for (let day of days) {
			resultSchedule.weeks[week][day] = [];
		}
	}
	
	// Process each week and day
	for (let week = 1; week <= totalWeeks; week++) {
		for (let day of days) {
			const week1 = ((week - 1) % weeks1) + 1;
			const week2 = ((week - 1) % weeks2) + 1;
			
			const periods1 = schedule1.weeks[week1] ? schedule1.weeks[week1][day] || [] : [];
			const periods2 = schedule2.weeks[week2] ? schedule2.weeks[week2][day] || [] : [];
			
			// For each period in schedule1, subtract overlaps with schedule2
			for (let p1 of periods1) {
				let remainingPeriods = [{...p1}];
				
				for (let p2 of periods2) {
					const newRemainingPeriods = [];
					
					for (let remaining of remainingPeriods) {
						if (remaining.start >= p2.end || remaining.end <= p2.start) {
							// No overlap
							newRemainingPeriods.push(remaining);
						} else {
							// There's overlap, split the remaining period
							if (remaining.start < p2.start) {
								newRemainingPeriods.push({
									start: remaining.start,
									end: p2.start,
									type: remaining.type
								});
							}
							if (remaining.end > p2.end) {
								newRemainingPeriods.push({
									start: p2.end,
									end: remaining.end,
									type: remaining.type
								});
							}
						}
					}
					
					remainingPeriods = newRemainingPeriods;
				}
				
				resultSchedule.weeks[week][day].push(...remainingPeriods);
			}
			
			// Sort periods by start time
			resultSchedule.weeks[week][day].sort((a, b) => a.start - b.start);
		}
	}
	
	return resultSchedule;
}

// Convert schedule to condensed standard format string
function scheduleToCondensedString(schedule) 
{
	const weekCount = getScheduleWeekCount(schedule);
	const days = ['S', 'M', 'T', 'W', 'R', 'F', 'A']; // Sun, Mon, Tue, Wed, Thu, Fri, Sat
	const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	
	let result = '[';
	
	for (let week = 1; week <= weekCount; week++) {
		if (week > 1) result += ',';
		result += `(W${week})[`;
		
		for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
			if (dayIndex > 0) result += ',';
			const dayName = dayNames[dayIndex];
			const dayCode = days[dayIndex];
			
			result += `${dayCode}[`;
			
			const periods = schedule.weeks[week] ? schedule.weeks[week][dayName] || [] : [];
			
			for (let periodIndex = 0; periodIndex < periods.length; periodIndex++) {
				if (periodIndex > 0) result += ',';
				const period = periods[periodIndex];
				result += `${period.type}${period.start}-${period.end}`;
			}
			
			result += ']';
		}
		
		result += ']';
	}
	
	result += ']';
	return result;
}

// Parse condensed standard format string back to schedule object
function parseCondensedScheduleString(condensedString) 
{
	const schedule = {
		id: nextTempScheduleId++,
		type: 'A',
		weeks: {}
	};
	
	// Remove outer brackets
	let content = condensedString.slice(1, -1);
	
	// Parse weeks
	// I hate regEx so much
	const weekRegex = /\(W(\d+)\)\[([^\]]*?(?:\[.*?\][^\]]*?)*)\](?=,\(W\d+\)|\]|$)/g;
	let weekMatch;
	
	while ((weekMatch = weekRegex.exec(content)) !== null) {
		const weekNum = parseInt(weekMatch[1]);
		const weekContent = weekMatch[2];	
		schedule.weeks[weekNum] = {};
		
		// Parse days
		const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
		const dayRegex = /[SMTWRFA]\[(.*?)\]/g;
		let dayMatch;
		let dayIndex = 0;
		
		while ((dayMatch = dayRegex.exec(weekContent)) !== null && dayIndex < 7) {
			const dayName = dayNames[dayIndex];
			const dayContent = dayMatch[1];
			
			schedule.weeks[weekNum][dayName] = [];
			
			if (dayContent) {
				// Parse periods
				const periodRegex = /([ALSPRN])(\d+)-(\d+)/g;
				let periodMatch;
				
				while ((periodMatch = periodRegex.exec(dayContent)) !== null) {
					schedule.weeks[weekNum][dayName].push({
						type: periodMatch[1],
						start: parseInt(periodMatch[2]),
						end: parseInt(periodMatch[3])
					});
				}
			}
			
			dayIndex++;
		}
	}
	
	return schedule;
}
        
// Convert schedule to user-friendly format
function scheduleToUserFriendlyString(schedule) 
{
    const weekCount = getScheduleWeekCount(schedule);
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    let result = [];
    
    for (let week = 1; week <= weekCount; week++) {
        let weekResult = `Week ${week}: `;
        let weekParts = [];
        let processedDays = new Set();
        
        // Check if week has any periods at all
        let hasAnyPeriods = false;
        for (let dayName of dayNames) {
            const periods = schedule.weeks[week] ? schedule.weeks[week][dayName] || [] : [];
            if (periods.length > 0) {
                hasAnyPeriods = true;
                break;
            }
        }
        
        if (!hasAnyPeriods) {
            weekResult += 'Empty Schedule';
            result.push(weekResult);
            continue;
        }
        
        // Process each day in order
        for (let i = 0; i < dayNames.length; i++) {
            const currentDay = dayNames[i];
            
            if (processedDays.has(currentDay)) continue;
            
            const currentPeriods = schedule.weeks[week] ? schedule.weeks[week][currentDay] || [] : [];
            
            // Skip days with no periods
            if (currentPeriods.length === 0) continue;
            
            // Find all days with identical schedules
            let matchingDays = [currentDay];
            
            for (let j = i + 1; j < dayNames.length; j++) {
                const compareDay = dayNames[j];
                if (processedDays.has(compareDay)) continue;
                
                const comparePeriods = schedule.weeks[week] ? schedule.weeks[week][compareDay] || [] : [];
				
                if (periodsMatch(currentPeriods, comparePeriods)) {
                    matchingDays.push(compareDay);
                }
            }
            
            // Mark all matching days as processed
            matchingDays.forEach(day => processedDays.add(day));
            
            // Format the day group
            let dayGroupStr = formatDayGroup(matchingDays, dayNames);
            
            // Format the periods for this group
            let periodsStr = formatPeriods(currentPeriods);
            
            weekParts.push(`${dayGroupStr} ${periodsStr}`);
        }
        
        weekResult += weekParts.join(', ');
        result.push(weekResult);
    }
    
    return result.join('. ') + '.';
}

// checks if two period arrays are identical
function periodsMatch(periods1, periods2) {
    if (periods1.length !== periods2.length) return false;
    
    // Sort both arrays by start time for comparison
    const sorted1 = [...periods1].sort((a, b) => a.start - b.start);
    const sorted2 = [...periods2].sort((a, b) => a.start - b.start);
    
    for (let i = 0; i < sorted1.length; i++) {
        if (sorted1[i].start !== sorted2[i].start || sorted1[i].end !== sorted2[i].end) {
            return false;
        }
    }
    
    return true;
}

// function to format a group of days
function formatDayGroup(days, allDayNames) 
{
    if (days.length === 1) {
        return days[0];
    }
    
    // Check if days are consecutive and more than 2
    if (days.length > 2 && areConsecutive(days, allDayNames)) {
        return `${days[0]}-${days[days.length - 1]}`;
    } else {
        return days.join('/');
    }
}

// function to check if days are consecutive
function areConsecutive(days, allDayNames) 
{
    // Get indices of the days
    const indices = days.map(day => allDayNames.indexOf(day)).sort((a, b) => a - b);
    
    // Check if indices are consecutive
    for (let i = 1; i < indices.length; i++) {
        if (indices[i] !== indices[i-1] + 1) {
            return false;
        }
    }
    
    return true;
}

// function to format periods for display
function formatPeriods(periods) 
{
    // Sort periods by start time
    const sortedPeriods = [...periods].sort((a, b) => a.start - b.start);
    
    return sortedPeriods.map(period => {
        const startStr = formatTimeUserFriendly(period.start);
        const endStr = formatTimeUserFriendly(period.end);
        return `${startStr}-${endStr}`;
    }).join('/');
}

// function to format time in user-friendly format
function formatTimeUserFriendly(minutes) 
{
    // Handle special case where 1440 should display as 12a (end of day)
    if (minutes === 1440) minutes = 0;
    
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    const period = hours >= 12 ? 'p' : 'a';
    const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
    
    if (mins === 0) {
        return `${displayHours}${period}`;
    } else {
        return `${displayHours}:${mins.toString().padStart(2, '0')}${period}`;
    }
}
        
// CareResults class and functions
class CareResults {
	constructor() {
		this.fullDays = 0;
		this.halfDays = 0;
		this.overTimeUnits = 0;
		this.dubOTUnits = 0;
		this.MFFD = 0;
		this.MFHD = 0;
		this.normFull = 0;
		this.normHalf = 0;
		this.partialDays = 0;
		this.sleepTime = 0;
		this.totalTime = 0;
		this.nonStandardTime = 0;
	}
}
        
// Calculate care results from a single schedule
function calculateCareFromSchedule(schedule) 
{
	const results = new CareResults();
	const weekCount = getScheduleWeekCount(schedule);
	const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	
	let totalDays = 0;
	
	// Process each week and day
	for (let week = 1; week <= weekCount; week++) {
		for (let dayName of dayNames) {
			const periods = schedule.weeks[week] ? schedule.weeks[week][dayName] || [] : [];
			
			let dayTotalMinutes = 0;
			let daySleepMinutes = 0;
			let dayNonStandardMinutes = 0;
			
			for (let period of periods) {
				const periodMinutes = period.end - period.start;
				dayTotalMinutes += periodMinutes;
				
				if (period.type === 'L') {
					daySleepMinutes += periodMinutes;
				}
				
				// Non-standard time: 0-360 (midnight to 6am) and 1080-1440 (6pm-midnight)
				const nonStandardStart = Math.max(0, Math.min(360, Math.max(period.start, 0)));
				const nonStandardEnd1 = Math.min(360, period.end);
				if (nonStandardEnd1 > nonStandardStart) {
					dayNonStandardMinutes += nonStandardEnd1 - nonStandardStart;
				}
				
				const nonStandardStart2 = Math.max(1080, period.start);
				const nonStandardEnd2 = Math.min(1440, period.end);
				if (nonStandardEnd2 > nonStandardStart2) {
					dayNonStandardMinutes += nonStandardEnd2 - nonStandardStart2;
				}
			}
			
			// Apply maximums
			dayTotalMinutes = Math.min(dayTotalMinutes, 960);
			//daySleepMinutes = Math.min(daySleepMinutes, 960);
			dayNonStandardMinutes = Math.min(dayNonStandardMinutes, 960);
			
			// Calculate day types based on total minutes
			if (dayTotalMinutes > 0) {
				totalDays++;
				
				if (dayTotalMinutes < 300) {
					results.halfDays += 1;
					results.normHalf += 1;
					if(dayName != 'Sun' && dayName != 'Sat')
					{
						results.MFHD += 1;
					}
				} else if (dayTotalMinutes <= 600) {
					results.fullDays += 1;
				} else if (dayTotalMinutes <= 900) {
					results.fullDays += 1;
					results.halfDays += 1;
					results.overTimeUnits += 1;
				} else {
					results.fullDays += 1;
					results.halfDays += 2;
					results.overTimeUnits += 1;
					results.dubOTUnits += 1;
				}
				if(dayTotalMinutes >= 300)
				{
					results.normFull += 1;
				}
				if(dayName != 'Sun' && dayName != 'Sat' && dayTotalMinutes >= 300)
				{
					results.MFFD += 1;
				}
				
				results.totalTime += dayTotalMinutes;
				if(daySleepMinutes > 0)
				{
					if(daySleepMinutes < 300)
					{
						daySleepMinutes = 300;
					}
					else if(daySleepMinutes < 600)
					{
						daySleepMinutes = 600;
					}
					else if(daySleepMinutes < 900)
					{
						daySleepMinutes = 900;
					}
					else{
						daySleepMinutes = 1200;
					}
				}
				results.sleepTime += daySleepMinutes;
				results.nonStandardTime += dayNonStandardMinutes;
			}
		}
	}
		
	// Calculate weekly averages
	if (weekCount > 0) {
		results.fullDays = results.fullDays / weekCount;
		results.halfDays = results.halfDays / weekCount;
		results.partialDays = results.partialDays / weekCount;
		results.MFFD = results.MFFD / weekCount;
		results.MFHD = results.MFHD / weekCount;
		results.normHalf = results.normHalf / weekCount;
		results.normFull = results.normFull / weekCount;
		results.totalTime = results.totalTime / weekCount;
		results.sleepTime = results.sleepTime / weekCount;
		results.nonStandardTime = results.nonStandardTime / weekCount;
	}

	
	return results;
}
		
//returns true if the schedule is empty
function scheduleIsEmpty(schedule)
{
	return ((!schedule) || (scheduleToCondensedString(schedule) === '[(W1)[S[],M[],T[],W[],R[],F[],A[]]]')); 
}

// Calculate care results from activity schedule and school schedule
function calculateCareFromTwoSchedules(activitySchedule, schoolSchedule) {
	const results = new CareResults();
	const weekCount1 = getScheduleWeekCount(activitySchedule);
	const weekCount2 = getScheduleWeekCount(schoolSchedule);
	const totalWeeks = lcm(weekCount1, weekCount2);
	const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	const schoolDays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
	
	// Process each week and day
	for (let week = 1; week <= totalWeeks; week++) {
		for (let dayName of dayNames) {
			const week1 = ((week - 1) % weekCount1) + 1;
			const week2 = ((week - 1) % weekCount2) + 1;
			
			const activityPeriods = activitySchedule.weeks[week1] ? 
				activitySchedule.weeks[week1][dayName] || [] : [];
			const schoolPeriods = schoolSchedule.weeks[week2] ? 
				schoolSchedule.weeks[week2][dayName] || [] : [];
			
			// Filter school periods to only include school/preschool types
			const validSchoolPeriods = schoolPeriods.filter(p => p.type === 'S' || p.type === 'P');
			
			let dayTotalMinutes = 0;
			let daySleepMinutes = 0;
			let dayNonStandardMinutes = 0;
			
			// Calculate total activity time
			for (let period of activityPeriods) {
				const periodMinutes = period.end - period.start;
				dayTotalMinutes += periodMinutes;
				
				if (period.type === 'L') {
					daySleepMinutes += periodMinutes;
				}
				
				// Calculate non-standard time
				const nonStandardStart = Math.max(0, Math.min(360, Math.max(period.start, 0)));
				const nonStandardEnd1 = Math.min(360, period.end);
				if (nonStandardEnd1 > nonStandardStart) {
					dayNonStandardMinutes += nonStandardEnd1 - nonStandardStart;
				}
				
				const nonStandardStart2 = Math.max(1080, period.start);
				const nonStandardEnd2 = Math.min(1440, period.end);
				if (nonStandardEnd2 > nonStandardStart2) {
					dayNonStandardMinutes += nonStandardEnd2 - nonStandardStart2;
				}
			}
			
			// Apply maximums
			dayTotalMinutes = Math.min(dayTotalMinutes, 960);
			//daySleepMinutes = Math.min(daySleepMinutes, 960);
			dayNonStandardMinutes = Math.min(dayNonStandardMinutes, 960);
			
			// Calculate day types
			if (dayTotalMinutes > 0) {
				let isPartialDay = false;
				
				// Check for partial day conditions (Mon-Fri only)
				if (schoolDays.includes(dayName) && validSchoolPeriods.length > 0 && dayTotalMinutes < 300) {
					// Check if activity is both before and after school
					const sortedActivity = activityPeriods.sort((a, b) => a.start - b.start);
					const sortedSchool = validSchoolPeriods.sort((a, b) => a.start - b.start);
					
					if (sortedActivity.length > 0 && sortedSchool.length > 0) {
						const firstActivity = sortedActivity[0];
						const lastActivity = sortedActivity[sortedActivity.length - 1];
						const firstSchool = sortedSchool[0];
						const lastSchool = sortedSchool[sortedSchool.length - 1];
						
						// Check if there's activity before school starts and after school ends
						const hasActivityBefore = firstActivity.start < firstSchool.start;
						const hasActivityAfter = lastActivity.end > lastSchool.end;
						
						if (hasActivityBefore && hasActivityAfter) {
							isPartialDay = true;
							results.normHalf += 1;
							results.partialDays += 1;
							if(dayName != 'Sun' && dayName != 'Sat')
							{
								results.MFHD += 1;
							}
						}
					}
				}
				
				if (!isPartialDay) {
					if (dayTotalMinutes < 300) {
						results.halfDays += 1;
						results.normHalf += 1;
						if(dayName != 'Sun' && dayName != 'Sat')
						{
							results.MFHD += 1;
						}
					} else if (dayTotalMinutes <= 600) {
						results.fullDays += 1;
					} else if (dayTotalMinutes <= 900) {
						results.fullDays += 1;
						results.halfDays += 1;
						results.overTimeUnits += 1;
					} else {
						results.fullDays += 1;
						results.halfDays += 2;
						results.overTimeUnits += 1;
						results.dubOTUnits += 1;
					}
				}
				if(dayTotalMinutes >= 300)
				{
					results.normFull += 1;
				}
				if(dayName != 'Sun' && dayName != 'Sat' && dayTotalMinutes >= 300)
				{
					results.MFFD += 1;
				}
				if(daySleepMinutes > 0)
				{
					if(daySleepMinutes < 300)
					{
						daySleepMinutes = 300;
					}
					else if(daySleepMinutes < 600)
					{
						daySleepMinutes = 600;
					}
					else if(daySleepMinutes < 900)
					{
						daySleepMinutes = 900;
					}
					else{
						daySleepMinutes = 1200;
					}
				}
				
				results.totalTime += dayTotalMinutes;
				results.sleepTime += daySleepMinutes;
				results.nonStandardTime += dayNonStandardMinutes;
			}
		}
	}
	
	// Calculate weekly averages
	if (totalWeeks > 0) {
		results.fullDays = results.fullDays / totalWeeks;
		results.halfDays = results.halfDays / totalWeeks;
		results.overTimeUnits = results.overTimeUnits / totalWeeks;
		results.dubOTUnits = results.dubOTUnits / totalWeeks;
		results.MFFD = results.MFFD / totalWeeks;
		results.MFHD = results.MFHD / totalWeeks;
		results.normHalf = results.normHalf / totalWeeks;
		results.normFull = results.normFull / totalWeeks;
		results.partialDays = results.partialDays / totalWeeks;
		results.totalTime = results.totalTime / totalWeeks;
		results.sleepTime = results.sleepTime / totalWeeks;
		results.nonStandardTime = results.nonStandardTime / totalWeeks;
	}
	
	return results;
}


// Compare two CareResults and return the larger one
function getLargerCareResult(result1, result2) 
{
	const score1 = (Math.ceil(result1.fullDays) * 2) + Math.ceil(result1.halfDays) + Math.ceil(result1.partialDays);
	const score2 = (Math.ceil(result2.fullDays) * 2) + Math.ceil(result2.halfDays) + Math.ceil(result2.partialDays);
	
	if (score1 > score2) {
		return result1;
	} else if (score2 > score1) {
		return result2;
	} else {
		// Scores are equal, compare total time
		return result1.totalTime >= result2.totalTime ? result1 : result2;
	}
}

// School age additional care vs standard increase care calculation function
function calculateComplexCareResult(result1, result2) 
{
	// First calculation: result1 * 40 + result2 * 12, then divide by 52
	const calc1 = new CareResults();
	calc1.fullDays = ((result1.fullDays * 40.0) + (result2.fullDays * 12.0)) / 52.0;
	calc1.halfDays = ((result1.halfDays * 40.0) + (result2.halfDays * 12.0)) / 52.0;
	calc1.partialDays = ((result1.partialDays * 40.0) + (result2.partialDays * 12.0)) / 52.0;
	calc1.totalTime = ((result1.totalTime * 40.0) + (result2.totalTime * 12.0)) / 52.0;
	calc1.sleepTime = ((result1.sleepTime * 40.0) + (result2.sleepTime * 12.0)) / 52.0;
	calc1.nonStandardTime = ((result1.nonStandardTime * 40.0) + (result2.nonStandardTime * 12.0)) / 52.0;
	
	calc1.overTimeUnits = ((result1.overTimeUnits * 40.0) + (result2.overTimeUnits * 12.0)) / 52.0;
	calc1.dubOTUnits = ((result1.dubOTUnits * 40.0) + (result2.dubOTUnits * 12.0)) / 52.0;
	calc1.MFFD = ((result1.MFFD * 40.0) + (result2.MFFD * 12.0)) / 52.0;
	calc1.MFHD = ((result1.MFHD * 40.0) + (result2.MFHD * 12.0)) / 52.0;
	calc1.normFull = ((result1.normFull * 40.0) + (result2.normFull * 12.0)) / 52.0;
	calc1.normHalf = ((result1.normHalf * 40.0) + (result2.normHalf * 12.0)) / 52.0;
	
	// Second calculation: result1 * 40 + 60 full days + 36000 minutes, then divide by 52
	const calc2 = new CareResults();
	calc2.fullDays = ((result1.fullDays * 40.0) + 60.0) / 52.0;
	calc2.halfDays = (result1.halfDays * 40.0) / 52.0;
	calc2.partialDays = (result1.partialDays * 40.0) / 52.0;
	calc2.totalTime = ((result1.totalTime * 40.0) + 36000.0) / 52.0;
	calc2.sleepTime = (result1.sleepTime * 40.0) / 52.0;
	calc2.nonStandardTime = (result1.nonStandardTime * 40.0) / 52.0;
	
	calc2.overTimeUnits = result1.overTimeUnits;
	calc2.dubOTUnits = result1.dubOTUnits;
	calc2.MFFD = ((result1.MFFD * 40.0) + 60) / 52.0;
	calc2.MFHD = (result1.MFHD * 40.0) / 52.0;
	calc2.normFull = ((result1.normFull * 40.0) + 60) / 52.0;
	calc2.normHalf = (result1.normHalf * 40.0) / 52.0;
	
	return getLargerCareResult(calc1, calc2);
}

// Check if first care result is larger than or equal to second
function careResultIsLargerOrEqual(result1, result2) {
	const score1 = Math.ceil((result1.fullDays * 2) + result1.halfDays + result1.partialDays);
	const score2 = Math.ceil((result2.fullDays * 2) + result2.halfDays + result2.partialDays);
	
	if (score1 > score2) {
		return true;
	} else if (score1 === score2) {
		return result1.totalTime >= result2.totalTime;
	} else {
		return false;
	}
}

//convert averageWeeklyCare to monthly
function careToMonthly(careResult)
{
 // Convert to monthly averages
 
	careResult.normFull = (((Math.min(5, careResult.normFull) * 52.0)/12.0) + (careResult.normFull > 5 ? (((careResult.normFull - 5) * 52.0)/12.0) : 0));
	careResult.normHalf = (((Math.min(5, careResult.normHalf) * 52.0)/12.0) + (careResult.normHalf > 5 ? (((careResult.normHalf - 5) * 52.0)/12.0) : 0));
	careResult.overTimeUnits = (((Math.min(5, careResult.overTimeUnits) * 52.0)/12.0) + (careResult.overTimeUnits > 5 ? (((careResult.overTimeUnits - 5) * 52.0)/12.0) : 0));
	careResult.dubOTUnits = (((Math.min(5, careResult.dubOTUnits) * 52.0)/12.0) + (careResult.dubOTUnits > 5 ? (((careResult.dubOTUnits - 5) * 52.0)/12.0) : 0));
	
	careResult.fullDays = (careResult.fullDays * 52.0) / 12.0;
	careResult.halfDays = (careResult.halfDays * 52.0) / 12.0;
	careResult.MFFD = (careResult.MFFD * 52.0) / 12.0;
	careResult.MFHD = (careResult.MFHD * 52.0) / 12.0;
	careResult.partialDays = (careResult.partialDays * 52.0) / 12.0;
	careResult.totalTime = (careResult.totalTime * 52.0) / 12.0;
	careResult.sleepTime = (careResult.sleepTime * 52.0) / 12.0;
	careResult.nonStandardTime = (careResult.nonStandardTime * 52.0) / 12.0;
	
	return careResult;
}

// Calculate age in years from birthdate
function calculateAge(birthdate) 
{
	const today = new Date();
	const birth = new Date(birthdate);
	let age = today.getFullYear() - birth.getFullYear();
	const monthDiff = today.getMonth() - birth.getMonth();
	
	if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
		age--;
	}
	
	return age;
}

// Generate unique calculation result ID
let nextCalculationResultId = 1;

function calculateCurrentCare()
{
	const careStartDate = document.getElementById('careStartDate').value
	if(!careStartDate) {
		alert('Start date for care must be specified!');
		console.log('Start date for care must be specified!');
		return;
	}
	calculateCare(data, 'calculationResults', careStartDate);
}

// recalculate care from a stored result, store it in 'recalculationSection' div
function recalculateStoredResult()
{
	const selectedResult = actualData.savedResults.find(r => r.id === Number(activeResultId));
	if(!selectedResult)
	{
		alert('Error: No result selected!');
		console.log('Error: No result selected!');
		return;
	}
	const careStartDate = document.getElementById('reCalcStartDate').value
	if(!careStartDate) {
		alert('Recalculation start date for care must be specified!');
		console.log('Recalculation start date for care must be specified!');
		return;
	}
	if(careStartDate === selectedResult.startDate)
	{
		alert('Recalculation start date for care is the same as the original start date!');
		console.log('Recalculation start date for care is the same as the original start date!');
		return;
	}
	
	// build myTempData using information based on the current selected stored result
	buildMyTemp(selectedResult);
	
	calculateCare(myTempData, 'recalculationSection', careStartDate);
	// clear myTempData
	clearTempData();
}

// If old result is selected, toggles to using temp data, and builds dataset from stored result data
function loadSavedResultState()
{
	document.getElementById('selectedCareResult').innerHTML = '';
	const selectedResult = actualData.savedResults.find(r => r.id === Number(activeResultId));
	if(!selectedResult)
	{
		alert('Error: No result selected!');
		console.log('Error: No result selected!');
		return;
	}
	if(!usingTemp)
	{
		toggleDataSource();
	}
	else // this shouldn't be possible
	{
		clearTempData();
	}
	buildMyTemp(selectedResult);
	refreshAll(); // refresh all screens and go to household screen
	showTab('household'); // schedules ? calculation ?
}

// Populate myTemp with all data needed for calculations using the data in the selected Result
function buildMyTemp(selectedResult)
{
	// populate all people and providers from real data these things can't be deleted
	myTempData.people = JSON.parse(JSON.stringify(actualData.people));
	myTempData.providers = JSON.parse(JSON.stringify(actualData.providers));
	// resultLines, savedResults, and shortSchedules will always be empty in myTempData, stored results will only ever be saved in actual Data
	
	myTempData.applications = [{headOfHouseholdId: selectedResult.HOH, id: selectedResult.appid}]; // populate applications with single application
	const uniqueResultChildren = [...new Set(actualData.shortSchedules.filter(s => s.did === Number(selectedResult.id) && s.type === 'P').map(obj => obj.clID))];
	uniqueResultChildren.forEach(c => {
	const myInc = actualData.shortSchedules.find(f=> f.did === Number(selectedResult.id) && f.clID === Number(c)).included;
		myTempData.householdMembers.push({ 
			applicationId: selectedResult.appid,
			included: myInc,
			memberType: 'C',
			personId: Number(c) });
		});
	const uniqueRemainingPeople = [...new Set(actualData.shortSchedules.filter(s => s.did === Number(selectedResult.id)).map(obj => obj.clID))];
		uniqueRemainingPeople.forEach(c => {
		const myInc = actualData.shortSchedules.find(f=> f.did === Number(selectedResult.id) && f.clID === Number(c)).included;
		if((!myTempData.householdMembers.find(f => Number(f.personId) === Number(c))) && (Number(c) != Number(selectedResult.HOH)))
		myTempData.householdMembers.push({ 
			applicationId: selectedResult.appid,
			included: myInc,
			memberType: 'A',
			personId: Number(c) });
		});
	// populate schedules, provider-child links, and activities
	actualData.shortSchedules.filter(s => s.did === Number(selectedResult.id)).forEach(l => { 
		// create a new schedule using the condensed schedule and input into schedules
		// Now uses compressedStringToSchedule instead of parseCondensedScheduleString
		let myNewSchedule = compressedStringToSchedule(l.sch);
		myNewSchedule.type = l.subType;
		
		if(l.type === 'P')
		{
			// if it is a provider-child link schedule, input the provider-child link into provider-child links and link the newly created scheduleid
			myTempData.providerLinks.push({applicationId: selectedResult.appid,
											locCare: l.loc,
											personId: l.clID,
											primary: l.isPrimary,
											providerId: l.linkID,
											scheduleId: myNewSchedule.id,
											subLoc: l.subLoc
											});
		}
		else
		{
			// If it is an activity schedule, create a new activity in activities and link the newly created scheduleid
			myTempData.activities.push({applicationId: selectedResult.appid,
											id: getNextActivityId(),
											careNeeded: l.careNeeded,
											name: l.actName,
											personId: l.clID,
											scheduleId: myNewSchedule.id,
											type: l.actType
											});
		}
		myTempData.schedules.push(myNewSchedule);
	});
	myTempData.activeApplicationId = selectedResult.appid;
}
		
// Main calculation function
function calculateCare(myData, myTargetElementId, careStartDate) 
{
	const dataSnapShot = JSON.stringify(data);
	const results = document.getElementById(myTargetElementId);
	if(!results)
	{
		console.log(`Error target elementID ${myTargetElementId} not found in document`);
		return;
	}
	// Always clear the two potential calculation display sections before starting a new calculation
	if(myTargetElementId === 'recalculationSection')
	{
		document.getElementById('calculationResults').innerHTML = '<p>No calculation performed yet.</p>';
		results.innerHTML = `<p><h3>Recalculating Care<h3></p>`;
	}
	else
	{
		document.getElementById('recalculationSection').innerHTML = '';
		results.innerHTML = '';
	}
	
	if (!myData.activeApplicationId) {
		results.innerHTML = '';
		alert('No active application selected');
		console.log('No active application selected');
		return;
	}
	 
	results.innerHTML += '<h4>Care Calculation Process</h4>';
	
	const app = myData.applications.find(a => a.id == myData.activeApplicationId);
	if (!app) {
		results.innerHTML += '<p class="error">Active application not found.</p>';
		return;
	}
	
	// Step 1: Error Checking
	let hasErrors = false;
	let hasWarnings = false;
	results.innerHTML += '<h5>Step 1: Error Checking</h5>';
	
	// Get all adults in household
	const headPerson = data.people.find(p => p.id === app.headOfHouseholdId);
	const adultMembers = data.householdMembers.filter(h => 
		h.applicationId == data.activeApplicationId && 
		h.included === 'Y' && 
		h.memberType === 'A'
	);
	
	const allAdults = [headPerson];
	adultMembers.forEach(member => {
		const person = data.people.find(p => p.id === member.personId);
		if (person) allAdults.push(person);
	});
	
	// Check if any included adult has no included activities
	allAdults.forEach(a => {
		const myActivities = data.activities.filter(d => 
		d.applicationId == data.activeApplicationId && 
		d.personId === a.id && d.careNeeded === true);
		if(myActivities.length === 0)
		{
			results.innerHTML += `<p class = "error">ERROR: Included household adult ${a.name} [${a.id}] has no activities requiring care.</p>`;
			console.log(`ERROR: Included household adult ${a.name} [${a.id}] has no activities requiring care.`);
			hasErrors = true;
		}
	});
	
	// Check adult activity overlaps
	for (let adult of allAdults) {
		const adultActivities = data.activities.filter(a => 
			a.applicationId == data.activeApplicationId && 
			a.personId === adult.id && a.careNeeded === true
		);
		
		if (adultActivities.length > 1) {
			for (let i = 0; i < adultActivities.length; i++) {
				for (let j = i + 1; j < adultActivities.length; j++) {
					const schedule1 = data.schedules.find(s => s.id === adultActivities[i].scheduleId);
					if(scheduleIsEmpty(schedule1))
					{
						results.innerHTML += `<p class = "warning">WARNING: ${adult.name} schedule for "${adultActivities[i].name}" is empty!</p>`;
						console.log(`WARNING: ${adult.name} schedule for "${adultActivities[i].name}" is empty!`);
						hasWarnings = true;
					}
					if(scheduleIsEmpty(schedule2))
					{
						results.innerHTML += `<p class = "warning">WARNING: ${adult.name} schedule for "${adultActivities[j].name}" is empty!</p>`;
						console.log(`WARNING: ${adult.name} schedule for "${adultActivities[j].name}" is empty!`);
						hasWarnings = true;
					}
					const schedule2 = data.schedules.find(s => s.id === adultActivities[j].scheduleId);
					
					if (schedule1 && schedule2 && schedulesOverlap(schedule1, schedule2)) {
						results.innerHTML += `<p class="error">ERROR: ${adult.name} has overlapping activity schedules: "${adultActivities[i].name}" ${scheduleToCondensedString(schedule1)} and "${adultActivities[j].name}" ${scheduleToCondensedString(schedule2)}</p>`;
						console.log(`ERROR: ${adult.name} has overlapping activity schedules: "${adultActivities[i].name}" ${scheduleToCondensedString(schedule1)} and "${adultActivities[j].name}" ${scheduleToCondensedString(schedule2)}`);
						hasErrors = true;
					}
				}
			}
		}
	}
	
	// Check children for multiple school activities
	const childMembers = data.householdMembers.filter(h => 
		h.applicationId == data.activeApplicationId && 
		h.included === 'Y' && 
		h.memberType === 'C'
	);
	
	if(childMembers.length === 0)
	{
		results.innerHTML += `<p class="error">ERROR: There are no children included in the household.</p>`;
		console.log(`ERROR: There are no children included in the household.`);
		hasErrors = true;
	}
	
	for (let child of childMembers) {
		const person = data.people.find(p => p.id === child.personId);
		const childActivities = data.activities.filter(a => 
			a.applicationId == data.activeApplicationId && 
			a.personId === child.personId &&
			(a.type === 'School' || a.type === 'Preschool')
		);
		const childAgeMonths = calculateCompleteMonths(person.birthdate, careStartDate);
		const cSD = new Date(careStartDate);
		const schoolDate = new Date(cSD.getTime() + cSD.getTimezoneOffset() * 60 * 1000);
		const lastSchoolStart = (cSD.getMonth() < 8 ? Number(cSD.getFullYear())-1 : Number(cSD.getFullYear())) + '-09-01';
		const ageLastSchoolYear = calculateCompleteMonths(person.birthdate, lastSchoolStart);
		
		if (childAgeMonths >= 84 && childActivities.length === 0) // School aged child without school schedule
		{
			results.innerHTML += `<p class = "warning">WARNING: School age child ${person.name} has no school schedule!</p>`;
			console.log(`WARNING: School age child ${person.name} has no school schedule!`);
			hasWarnings = true;
		}
		else if (ageLastSchoolYear >= 60 && childActivities.length === 0) // Potentially School aged child without school schedule
		{
			results.innerHTML += `<p class = "warning">WARNING: ${person.name} has no school schedule but was school aged at the begining of the most recent school year!</p>`;
			console.log(`WARNING: ${person.name} has no school schedule but was school aged at the begining of the most recent school year!`);
			hasWarnings = true;
		}
		
		if (childActivities.length > 1) 
		{
			results.innerHTML += `<p class="error">ERROR: ${person ? person.name : 'Unknown child'} has multiple school/preschool activities.</p>`;
			console.log(`ERROR: ${person ? person.name : 'Unknown child'} has multiple school/preschool activities.`);
			hasErrors = true;
		}
		childActivities.forEach(a => {
			const schedule1 = data.schedules.find(s => s.id === a.scheduleId);
			if(scheduleIsEmpty(schedule1))
			{
				results.innerHTML += `<p class="warning">WARNING: School schedule for ${person.name} is empty!</p>`;
				console.log(`WARNING: School schedule for ${person.name} is empty!`);
				hasWarnings = true;
			}
			if(((childAgeMonths >= 84) || (ageLastSchoolYear >= 60)) && a.type === 'Preschool') // School-aged child with preschool type schedule
			{
				results.innerHTML += `<p class="warning">WARNING: School age child ${person.name} has a preschool type schedule!</p>`;
				console.log(`WARNING: School age child ${person.name} has a preschool type schedule!`);
				hasWarnings = true;
			}
		});
	}
	
	// verify that none of the children have provider-link schedules that overlap, also check for any blank prr schedules!
	let skipPrrs = [];
	data.providerLinks.filter(f => f.applicationId === Number(data.activeApplicationId)).forEach(l => {
		const childName = data.people.find(x => x.id === l.personId).name;
		const schedule1 = data.schedules.find(s => s.id === l.scheduleId);
		if(scheduleIsEmpty(schedule1))
		{
			results.innerHTML += `<p class="error">ERROR: ${childName} schedule for care with provider: [${l.providerId}] is empty!</p>`;
			console.log(`ERROR: ${childName} schedule for care with provider: [${l.providerId}] is empty!`);
			hasErrors = true;
		}
		data.providerLinks.filter(g => g.applicationId === l.applicationId && g.providerId != l.providerId && g.personId === l.personId).forEach( m => {
			const schedule2 = data.schedules.find(s => s.id === m.scheduleId);
			if(skipPrrs.filter(s => (((s.prr1 === m.providerId) && (s.prr2 === l.providerId)) || ((s.prr2 === m.providerId) && (s.prr1 === l.providerId)))).length === 0)
			{
				if (schedule1 && schedule2 && schedulesOverlap(schedule1, schedule2)) {
					results.innerHTML += `<p class="error">ERROR: ${childName} has overlapping provider care schedules with providers: [${l.providerId}] ${scheduleToCondensedString(schedule1)} and [${m.providerId}] ${scheduleToCondensedString(schedule2)}</p>`;
					console.log(`ERROR: ${childName} has overlapping provider care schedules with providers: [${l.providerId}]: ${scheduleToCondensedString(schedule1)} and [${m.providerId}]: ${scheduleToCondensedString(schedule2)}`);
					skipPrrs.push({prr1: l.providerId, prr2: m.providerId});
					hasErrors = true;
				}
			}
		});
	});
	
	if (hasErrors) {
		results.innerHTML += '<p class="error">Calculation cannot continue due to errors above.</p>';
		return;
	}
	else if(hasWarnings){
		results.innerHTML += '<p class = "warning">No halting issues found.</p>';
	}
	else {
		results.innerHTML += '<p style="color: green;">No issues found.</p>';
	}
	
	// Step 2: Calculate care for application
	results.innerHTML += `<h5>Step 2: Calculating care for application ${data.activeApplicationId}</h5>`;
	
	// Determine number of adults
	const adultCount = allAdults.length;
	results.innerHTML += `<p>This is a ${adultCount} parent household.</p>`;
	
	// Create combined schedules for each adult
	const adultCombinedSchedules = [];
	for (let adult of allAdults) {
		const adultActivities = data.activities.filter(a => 
			a.applicationId == data.activeApplicationId && 
			a.personId === adult.id
		);
		
		if (adultActivities.length === 0) {
			// No activities, create empty schedule
			const emptySchedule = createTempEmptySchedule('A');
			adultCombinedSchedules.push(emptySchedule);
			results.innerHTML += `<p>${adult.name}'s Schedule: No scheduled periods</p>`;
		} else if (adultActivities.length === 1) {
			// Single activity
			const schedule = data.schedules.find(s => s.id === adultActivities[0].scheduleId);
			if (schedule) {
				adultCombinedSchedules.push(schedule);
				results.innerHTML += `<p>${adult.name}'s Schedule: ${scheduleToUserFriendlyString(schedule)}</p>`;
			}
		} else {
			// Multiple activities, combine them
			let combinedSchedule = data.schedules.find(s => s.id === adultActivities[0].scheduleId);
			for (let i = 1; i < adultActivities.length; i++) {
				const nextSchedule = data.schedules.find(s => s.id === adultActivities[i].scheduleId);
				if (nextSchedule) {
					combinedSchedule = combineSchedules(combinedSchedule, nextSchedule);
				}
			}
			adultCombinedSchedules.push(combinedSchedule);
			results.innerHTML += `<p>${adult.name}'s Schedule: ${scheduleToUserFriendlyString(combinedSchedule)}</p>`;
		}
	}
	
	// Calculate household adults combined schedule (overlap of all adults)
	let householdSchedule = adultCombinedSchedules[0];
	for (let i = 1; i < adultCombinedSchedules.length; i++) {
		householdSchedule = getScheduleOverlap(householdSchedule, adultCombinedSchedules[i]);
	}
	
	results.innerHTML += `<p>Household Adults Combined Schedule: ${scheduleToUserFriendlyString(householdSchedule)}</p>`;
	
	// Check 110 hour rule
	const householdCareResult = careToMonthly(calculateCareFromSchedule(householdSchedule));
	const meets110 = householdCareResult.totalTime >= 6540;
	results.innerHTML += `<p>This household ${meets110 ? 'meets' : "doesn't meet"} the 110 hour rule.</p>`;
	
	//If there is no care for the household, add message and end
	if(careToMonthly.totalTime === 0)
	{
		results.innerHTML += '<p>No care is required for this household. Please review schedules for potential errors.</p>';
		return;
	}
	// All household-level calculations are complete
	
	// Process each child-provider pair
	const providerLinks = data.providerLinks.filter(l => (l.applicationId == data.activeApplicationId) && childMembers.find(c => c.personId === l.personId));
	
	if(providerLinks.length === 0)
	{
		results.innerHTML += '<p>There are no children that require care with any provider in this household. Please review schedules for potential errors.</p>';
		return;
	}
	
	tempResultLines.length = 0; // build new temp results array to allow the user to save the data from the calculation
	let myL = 1;
	// set up the tempResult
	tempResult.id = getNextResultId();
	tempResult.appid = Number(data.activeApplicationId);
	tempResult.HOH = data.applications.find(a => a.id === Number(data.activeApplicationId)).headOfHouseholdId;
	tempResult.name = data.people.find(p => p.id === Number(tempResult.HOH)).name;
	tempResult.birthdate = data.people.find(p => p.id === Number(tempResult.HOH)).birthdate;
	tempResult.startDate = careStartDate;
	tempResult.saveDate = new Date().toLocaleDateString('en-CA');
	let myCalcResults = [];
	let myCareClients = [];
	const providerTypeMap = { 'C': 'Center', 'F': 'FFN', 'H': 'LFH' };
	
	// build array of calcResults
	for (let link of providerLinks) {
		const provider = data.providers.find(p => p.id === link.providerId);
		const child = data.people.find(p => p.id === link.personId);
		const providerSchedule = data.schedules.find(s => s.id === link.scheduleId);
		
		if (!provider || !child || !providerSchedule) continue;
		
		let finalSchedule = householdSchedule;
		
		// Check for non-care activities
		// Limit this to MONTHLYUNITCALC only
		if(getCalculationFunction(provider.type, careStartDate) === 'MONTHLYUNITCALC')
		{
			const childNonCareActivities = data.activities.filter(a => 
				a.applicationId == data.activeApplicationId && 
				a.personId === child.id &&
				a.type === 'Non care'
			);
			
			// Subtract non-care schedules
			for (let nonCareActivity of childNonCareActivities) {
				const nonCareSchedule = data.schedules.find(s => s.id === nonCareActivity.scheduleId);
				if (nonCareSchedule) {
					finalSchedule = subtractSchedule(finalSchedule, nonCareSchedule);
				}
			}
		}
		
		// Get overlap with provider schedule
		finalSchedule = getScheduleOverlap(finalSchedule, providerSchedule);
		
		// Calculate care result
		const initCareResult = calculateCareFromSchedule(finalSchedule); // weeklySchedule
		
		// Check if child has multiple providers
		const childProviderLinks = providerLinks.filter(l => l.personId === child.id);
		const multProvs = childProviderLinks.length > 1;
		const isPrimary = link.primary === 'Y';
		
		
		// Check if child is school-aged
		const childAge = calculateAge(child.birthdate);
		const childSchoolActivities = data.activities.filter(a => 
			a.applicationId == data.activeApplicationId && 
			a.personId === child.id &&
			a.type === 'School'
		);

		const childPreschoolActivities = data.activities.filter(a => 
			a.applicationId == data.activeApplicationId && 
			a.personId === child.id &&
			a.type === 'Preschool'
		);
		
		const schoolAge = (childSchoolActivities.length > 0 && childAge >= 5) || childAge >= 7;
		const preschoolAge = ((!schoolAge) && ((childPreschoolActivities.length > 0) || (childSchoolActivities.length > 0)));
		
		let schoolOverlap = false;
		let schoolYearCareResult = null;
		let initSchoolYearCareResult = null;
	   
		// If the child is schoolaged or preschool aged, determine if the school schedule affects care
		// If it does, remove the school or preschool schedule from the finalSchedule
		// If this is the primary, and the schedule affects care then use the calculateComplexCareResult function to determine the schoolYearCareResult
		// Otherwise, if this is not the primary use standard careResult

		if(schoolAge === true || preschoolAge === true)
		{
			if(schoolAge === true)
			{
				for (let schoolActivity of childSchoolActivities) 
				{
					const schoolSchedule = data.schedules.find(s => s.id === schoolActivity.scheduleId);
					if (schoolSchedule && schedulesOverlap(finalSchedule, schoolSchedule)) 
					{
						schoolOverlap = true;
						const schoolYearSchedule = subtractSchedule(finalSchedule, schoolSchedule);
						schoolYearCareResult = calculateCareFromTwoSchedules(schoolYearSchedule, schoolSchedule);
						break;
					}
				}
			}
			else
			{
				for (let preschoolActivity of childPreschoolActivities) 
				{
					const preschoolSchedule = data.schedules.find(s => s.id === preschoolActivity.scheduleId);
					if (preschoolSchedule && schedulesOverlap(finalSchedule, preschoolSchedule)) 
					{
						schoolOverlap = true;
						const schoolYearSchedule = subtractSchedule(finalSchedule, preschoolSchedule);
						schoolYearCareResult = calculateCareFromTwoSchedules(schoolYearSchedule, preschoolSchedule);
						break;
					}
				}
			}
			if(schoolOverlap && isPrimary && getCalculationFunction(provider.type, careStartDate) === 'MONTHLYUNITCALC')
			{
				initSchoolYearCareResult =  JSON.parse(JSON.stringify(schoolYearCareResult));
				schoolYearCareResult = calculateComplexCareResult(schoolYearCareResult, initCareResult);
			}	
		} 
		if(schoolYearCareResult === null)
		{
			schoolYearCareResult = JSON.parse(JSON.stringify(initCareResult));
			initSchoolYearCareResult =  JSON.parse(JSON.stringify(schoolYearCareResult));
		}
		if(initSchoolYearCareResult === null)
		{
			initSchoolYearCareResult =  JSON.parse(JSON.stringify(schoolYearCareResult));
		}

		// convert care results to monthly results
		schoolYearCareResult = careToMonthly(JSON.parse(JSON.stringify(schoolYearCareResult)));
		careResult = careToMonthly(JSON.parse(JSON.stringify(initCareResult)));
		
		if(schoolYearCareResult.totalTime > careResult.totalTime)
		{
			careResult = JSON.parse(JSON.stringify(schoolYearCareResult));
		}
		
		// Check 110 hour rule for single provider
		const care110 = schoolYearCareResult.totalTime >= 6540 && !multProvs;
		const summ110 = careResult.totalTime >= 6540 && ! multProvs; // Care during the summer months exceeds 110 hrs 
		// for all 110 rules it is actually anything over 109 hours
		
		// Create calculation result object CALC_RESULT
		const calculationResult = {
			id: nextCalculationResultId++,
			providerId: provider.id,
			region: provider.region,
			clientId: child.id,
			name: child.name,
			totalTotalTime: 0, // this will be updated after all calculationResults are created, used for sorting
			totalTotalInitTime: 0, // this will be updated after all calculationResults are created, used for sorting
			myFunc: getCalculationFunction(provider.type, careStartDate),
			applicationId: parseInt(data.activeApplicationId),
			startDate: careStartDate,
			birthdate: child.birthdate,
			ageMonths: calculateCompleteMonths(child.birthdate, careStartDate),
			providerType: provider.type,
			providerName: provider.name,
			locCare: link.locCare,
			subLoc: link.subLoc ? link.subLoc : link.locCare,
			meets110: meets110,
			multProvs: multProvs,
			isPrimary: isPrimary,
			schoolAge: schoolAge,
			preschoolAge: preschoolAge,
			schoolOverlap: schoolOverlap,
			care110: care110,
			summ110: summ110,
			SummerFullDays: Math.ceil(careResult.fullDays),
			SummerHalfDays: Math.ceil(careResult.halfDays) + Math.ceil(careResult.partialDays), // Summer can not have partial days
			SummerNormFull: Math.ceil(careResult.normFull),
			SummerNormHalf: Math.ceil(careResult.normHalf),
			SummerOverTimeUnits: Math.ceil(careResult.overTimeUnits) + Math.ceil(careResult.dubOTUnits),
			SummerPartialDays: 0, // Summer can not have partial days
			SummerSleepTime: careResult.sleepTime,
			SummerTotalTime: careResult.totalTime,
			SummerNonStandardTime: provider.type === 'F' ? 0 : careResult.nonStandardTime,
			SummerMFFullDays: Math.ceil(careResult.MFFD),
			SummerMFHalfDays: Math.ceil(careResult.MFHD),
			initSchoolFullDays: Math.ceil(initSchoolYearCareResult.fullDays),
			initSchoolPartDays: provider.type === 'C' ? 0 : Math.ceil(initSchoolYearCareResult.partialDays),
			initSchoolHalfDays: Math.ceil((provider.type === 'C' ? initSchoolYearCareResult.partialDays : 0) + initSchoolYearCareResult.halfDays),
			initSchoolMFFullDays: Math.ceil(initSchoolYearCareResult.MFFD),
			initSchoolMFHalfDays: Math.ceil(initSchoolYearCareResult.MFHD),
			initCareResultTotalTime: initCareResult.totalTime,
			weeklyFD: Math.ceil(initCareResult.normFull),
			weeklyHD: Math.ceil(initCareResult.normHalf),
			schoolWeeklyFD: Math.ceil(initSchoolYearCareResult.normFull),
			schoolWeeklyHD: Math.ceil(initSchoolYearCareResult.normHalf),
			fullDays: Math.ceil(schoolYearCareResult.fullDays),
			normFull: Math.ceil(schoolYearCareResult.normFull),
			halfDays: Math.ceil((provider.type === 'C' ? schoolYearCareResult.partialDays : 0) + schoolYearCareResult.halfDays),
			normHalf: Math.ceil(schoolYearCareResult.normHalf),
			MFFullDays: Math.ceil(schoolYearCareResult.MFFD),
			MFHalfDays:Math.ceil(schoolYearCareResult.MFHD),
			overTimeUnits: Math.ceil(schoolYearCareResult.overTimeUnits) + Math.ceil(schoolYearCareResult.dubOTUnits),
			partialDays: provider.type === 'C' ? 0 : Math.ceil(schoolYearCareResult.partialDays),
			sleepTime: schoolYearCareResult.sleepTime,
			totalTime: schoolYearCareResult.totalTime,
			nonStandardTime: provider.type === 'F' ? 0 : schoolYearCareResult.nonStandardTime,
			finalScheduleString: scheduleToCondensedString(finalSchedule),
			childSchoolScheduleString: childSchoolActivities.length > 0 ? 
				scheduleToCondensedString(data.schedules.find(s => s.id === childSchoolActivities[0].scheduleId)) : ''
		};
		myCalcResults.push(calculationResult);
	}
	// build the array of unique clients with each non9CodedTotal set to 230 (myCareClients)
	const myUniqueCareClients = [...new Set(myCalcResults.map(obj => obj.clientId))];
	for(let i = 0; i < myUniqueCareClients.length; i++)
	{
		myCareClients.push({clientId: myUniqueCareClients[i], totalTotalTime: 0.0, non9CodedTotal: 230.0, totalTotalInitTime: 0.0});
	}
	// add all the totalTime of the individual calculationResults for each client to the client array
	myCalcResults.forEach(r => { 
		myCareClients.find(m => m.clientId === r.clientId).totalTotalTime += r.totalTime;
		myCareClients.find(m => m.clientId === r.clientId).totalTotalInitTime += r.initCareResultTotalTime;
		});
	// set the totalTotalTime and totalTotalInitTime from the individual children into each calculationResult element
	
	for(let i = 0; i < myCalcResults.length; i++)
	{
		myCalcResults[i].totalTotalTime = myCareClients.find(m => m.clientId === myCalcResults[i].clientId).totalTotalTime;
		myCalcResults[i].totalTotalInitTime = myCareClients.find(m => m.clientId === myCalcResults[i].clientId).totalTotalInitTime;
	}
	
	// Sort the myCalcResults in place, order by totalTotalTime (descending), then birthdate (youngest to oldest), then client ID (largest to smallest), then isPrimary, then totalTime 
	myCalcResults.sort((a, b) => {
		if (Math.min(a.totalTotalTime, a.totalTotalInitTime) !== Math.min(b.totalTotalTime, b.totalTotalInitTime)) // First totalTotalTime (descending)
		{
			return (Math.min(b.totalTotalTime, b.totalTotalInitTime) - Math.min(a.totalTotalTime, a.totalTotalInitTime));
		}
		if((new Date(a.birthdate)) !== (new Date(b.birthdate))) // Then youngest to oldest
		{
			return ((new Date(b.birthdate)) - (new Date(a.birthdate)));
		}
		if(Number(a.clientId) !== Number(b.clientId)) // then largest to smallest clientID
		{
			return Number(b.clientId) - Number(a.clientId);
		}
		if(a.isPrimary !== b.isPrimary) // (if we are here there are multiple providers for one client, isPrimary should be listed first
		{
			if (a.isPrimary === true)
			{
				return -1;
			}
				return 1;
		}
		if(a.totalTime !== b.totalTime) // highest to lowest amount of care after isPrimary
		{
			return b.totalTime - a.totalTime;
		}
		return Number(a.providerId) - Number(b.providerId); // last possible criteria is providerID
		});
	// Loop through the sorted calcResults and display the results for each child in order
	// Build the careResults object for user to store results
	for(let i = 0; i < myCalcResults.length; i++)
	{
		let calculationResult = myCalcResults[i];
		
		results.innerHTML += `<h4>Child ${calculationResult.name} (${getFormattedDate(calculationResult.birthdate)}) is using care with ${providerTypeMap[calculationResult.providerType]} provider ${calculationResult.providerName}.</h4>`;
		if (calculationResult.multProvs) {
			results.innerHTML += `<p>This child is attending multiple providers${calculationResult.isPrimary ? ' and this is the primary provider.' : ' but this is not the primary provider.'}</p>`;
			
			if (calculationResult.initCareResultTotalTime === 0) {
				results.innerHTML += '<p>No care is needed with this provider.</p>';
				continue;
			}
		}
		if(calculationResult.schoolAge || calculationResult.preschoolAge)
		{
			if(calculationResult.schoolOverlap && calculationResult.isPrimary)
			{
				results.innerHTML += `<p>This child is ${calculationResult.preschoolAge ? 'pre':''}school aged, and this is the primary provider.</p>`;
			}
			else
			{
				let addHTML = '';
				addHTML += `<p>This child is ${calculationResult.preschoolAge ? 'pre':''}school aged,`;
				if(calculationResult.schoolOverlap)
				{
					addHTML += `and care with this provider is affected.</p>`;	
				}
				else
				{
					addHTML += `but care with this provider is unaffected.</p>`;	
				}
				results.innerHTML += addHTML;
			}
		}
		results.innerHTML += `<p>This child requires care an average of ${(calculationResult.totalTime / 60.0).toFixed(1)} hours per month with this provider.</p>`;
		if (calculationResult.care110) {
			results.innerHTML += '<p>Care for this child meets the 110 hour rule.</p>';
		}
		// initial text for the child is complete
		
		// Now determine authorizations and output text for specific care to authorize
		/*
			CALCFUNCTIONS:
			MONTHLYUNITCALC -- LFH and CC monthly unit calculations
			FFNCALCHRLY -- FFN hourly calculations
			DAILYUNITCALC -- CC daily units Full days, Half Days, Overtime units
		*/
		let careLines = {};
		let non9CodeRemain = Number(myCareClients.find(c=> c.clientId === calculationResult.clientId).non9CodedTotal);
		switch(calculationResult.myFunc)
		{
			case 'MONTHLYUNITCALC': careLines = determineMonthlyAuthorizations(calculationResult, non9CodeRemain); break;
			case 'FFNCALCHRLY': careLines = determineHourlyAuthorizations(calculationResult, non9CodeRemain); break;
			case 'DAILYUNITCALC': careLines = determineDailyAuthorizations(calculationResult, non9CodeRemain); break;
			default : continue; break;
		}
		for(let c of careLines.summerLines){
			if(c.xCode === '0')
			{
				non9CodeRemain -= ((c.units.fd * 10) + ((c.units.pd + c.units.hd) * 5) + (c.units.hr));
			}
		}
		myCareClients.find(c=> c.clientId === calculationResult.clientId).non9CodedTotal = Math.max(0,non9CodeRemain);
		
		//add the text for the authlines
		let myHTMLString = ''
		myHTMLString += `<h5> Authorize the following lines of care to this provider (${calculationResult.providerId}):</h5><div><ul>`;
		for (let c of careLines.authLines){
			if(c.inc)
			{
				tempResultLines.push({rid: tempResult.id, line: myL++, clID: calculationResult.clientId, prrID: calculationResult.providerId, xCode: c.xCode, 
				region: calculationResult.region, numUnits:c.authUnits, exp: (calculationResult.myFunc === 'MONTHLYUNITCALC' ? true : false), units: c.units, rate: c.amt, ttl: (c.amt * c.authUnits) + c.excess, excess: c.excess, isSummer: false, authType: c.type});
			}
			myHTMLString += `<li>${displayLine(c, careStartDate)}`;
			if(isCompoundUnits(c) || ((calculationResult.myFunc === 'MONTHLYUNITCALC') && ((c.units.fd + c.units.hd + c.units.pd) > 0)))
			{
				myHTMLString += ` Based on the following: <ul>`;
					if(Number(c.units.fd) > 0) {myHTMLString += `<li>${c.units.fd} Full Day Units at ${Number(c.rates.fd).toLocaleString('en-US', {style: 'currency', currency: 'USD'})} per unit.</li>`;}
					if(Number(c.units.pd) > 0) {myHTMLString += `<li>${c.units.pd} Partial Day Units at ${Number(c.rates.pd).toLocaleString('en-US', {style: 'currency', currency: 'USD'})} per unit.</li>`;}
					if(Number(c.units.hd) > 0) {myHTMLString += `<li>${c.units.hd} Half Day Units at ${Number(c.rates.hd).toLocaleString('en-US', {style: 'currency', currency: 'USD'})} per unit.</li>`;}
				myHTMLString += `</ul>`;
			}
			myHTMLString += `</li>`;
		}
		myHTMLString += `</ul></div>`;
		if(calculationResult.schoolAge){
			if (careLines.summerChg){
				myHTMLString += `<h5> For the summer months authorize the following lines of care:</h5><div><ul>`;
				for (let c of careLines.summerLines){
					if(c.inc)
					{
						tempResultLines.push({rid: tempResult.id, line: myL++, clID: calculationResult.clientId, prrID: calculationResult.providerId, xCode: c.xCode,
						region: calculationResult.region, numUnits:c.authUnits, exp: (calculationResult.myFunc === 'MONTHLYUNITCALC' ? true : false), units: c.units, rate: c.amt, ttl: (c.amt * c.authUnits) + c.excess, excess: c.excess, isSummer: true, authType: c.type});
					}
					myHTMLString += `<li>${displayLine(c, careStartDate)}`;
					if(isCompoundUnits(c) || ((calculationResult.myFunc === 'MONTHLYUNITCALC') && ((c.units.fd + c.units.hd + c.units.pd) > 0)))
					{
						myHTMLString += ` Based on the following: <ul>`;
							if(Number(c.units.fd) > 0) {myHTMLString += `<li>${c.units.fd} Full Day Units at ${Number(c.rates.fd).toLocaleString('en-US', {style: 'currency', currency: 'USD'})} per unit.</li>`;}
							if(Number(c.units.pd) > 0) {myHTMLString += `<li>${c.units.pd} Partial Day Units at ${Number(c.rates.pd).toLocaleString('en-US', {style: 'currency', currency: 'USD'})} per unit.</li>`;}
							if(Number(c.units.hd) > 0) {myHTMLString += `<li>${c.units.hd} Half Day Units at ${Number(c.rates.hd).toLocaleString('en-US', {style: 'currency', currency: 'USD'})} per unit.</li>`;}
						myHTMLString += `</ul>`;
					}
				}
				myHTMLString += `</ul></div>`;
			}
			else{
				myHTMLString += `<h5> No Changes are needed for the summer.</h5>`
			}
		}
		results.innerHTML += myHTMLString;
		if(verboseReporting)
		{
			console.log(JSON.stringify(calculationResult, null, 2));
		}
	}      
	
	results.innerHTML += '<p><strong>Calculation process completed.</strong></p>';
	if(tempResultLines.length > 0) 
	{
		results.innerHTML += `<p><div id = "saveResultsButton"><button onclick="saveTempResults()" style="background: #28a745; font-size: 16px; padding: 15px 30px;">Save Care Results</button><div></p>`;
	}
	
	if(JSON.stringify(data) != dataSnapShot)
	{
		console.log("Error: data was modified in the calculateCareFunction!!");
	}
}
// end of calculateCare function

// add the tempResults to the savedResults, first update any existing results for this application to primary = false
// This function should always push results to the actualData
// if we are currently using tempData, after push, toggle back to normal data.
function saveTempResults()
{
	// set all other saved results 
	actualData.savedResults.forEach(res => {
		if (res.appid === Number(tempResult.appid) && res.isPrimary === true) {
			res.isPrimary = false;
		}
	});
	actualData.savedResults.push(JSON.parse(JSON.stringify(tempResult)));
	
	// save all current household/schedule information in shortSchedules attached to this result
	data.activities.filter(a => a.applicationId === Number(data.activeApplicationId)).forEach(e => {
		let myPerson = data.people.find(p => p.id === e.personId);
		let myHHMember = data.householdMembers.find(m => m.applicationId === Number(data.activeApplicationId) && m.personId === e.personId);
		// it might be the HOH who is not in the household, but they are always included for calculation
		let myInc = myHHMember ? myHHMember.included : 'Y'
		// Now uses scheduleToCompressedString for shortSchedule storage and retrieval
		actualData.shortSchedules.push({did: tempResult.id,
									type: 'A',
									clID: myPerson.id,
									careNeeded: e.careNeeded,
									included: myInc,
									linkID: null,
									loc: null,
									subLoc: null,
									isPrimary: null,
									actName: e.name,
									actType: e.type,
									subType: data.schedules.find(s => s.id === e.scheduleId).type,
									exp: (`* ${e.type} schedule for ${myPerson.name} (${e.personId})-${e.name} ${myInc === 'Y' ? (e.careNeeded ? '' : '- No Care Needed.') : '- Not Included.'}`),
									sch: scheduleToCompressedString(data.schedules.find(s => s.id === e.scheduleId))
								});
	});
	data.providerLinks.filter(p => p.applicationId === Number(data.activeApplicationId)).forEach(r => {
		let myPrrName = data.providers.find(p => p.id === r.providerId).name;
		let myPerson = data.people.find(p => p.id === r.personId);
		let myHHMember = data.householdMembers.find(m => m.applicationId === Number(data.activeApplicationId) && m.personId === r.personId);
		actualData.shortSchedules.push({did: tempResult.id,
									type: 'P',
									clID: myPerson.id,
									careNeeded: true,
									included: myHHMember.included,
									linkID: r.providerId,
									loc: r.locCare,
									subLoc: r.subLoc,
									isPrimary: r.primary,
									actName: null,
									actType: null,
									subType : 'R',
									exp: `* ${(r.primary === 'Y' ? 'Primary ' : 'Secondary ')} provider ${myPrrName} [#${r.providerId}] for child ${myPerson.name} [${r.personId}] ${myHHMember.included === 'N' ? '(Not included)':''}`,
									sch: scheduleToCompressedString(data.schedules.find(s => s.id === r.scheduleId))
								});
	});
	
	// add tempLines to saved result Lines
	tempResultLines.forEach(l => {actualData.resultLines.push(l)});
	
	// reset tempResult and tempLines
	tempResult.id = getNextResultId();
	tempResult.saveDate = new Date().toLocaleDateString('en-CA');
	tempResultLines.length = 0;
	
	// hide the save button
	const saveButton = document.getElementById('saveResultsButton');
	saveButton.style.visibility = 'hidden';
	saveButton.style.display = 'none';

	if(usingTemp === true)
	{
		toggleDataSource();
	}
	refreshSavedResults();
	saveData();
}

// convert to line for an authorization 
// {type: 'Err', xCode: '0', authUnits: 0, amt: 0, units: [{fd: 0, hd: 0, pd: 0, hr: 0}], excess : 0, inc: false, msg:'Provider type not yet implemented.'}
function displayLine(careLine, onDt)
{
	if(!careLine.inc){
		return careLine.msg;
	}
	let myLine = '';
	let mySvc = getSvcCodeObj(careLine.type, onDt);
	
	myLine += 'Service Code [' + careLine.xCode + mySvc.svcCode + '] ' + mySvc.desc + ' ' + careLine.authUnits + ' units at a rate of ' 
		+ Number(careLine.amt).toLocaleString('en-US', {style: 'currency', currency: 'USD'}) + ' per unit.';
	if(careLine.msg.length > 0)
	{
		myLine += ' [' + careLine.msg + '].';
	}
	
	return myLine;
}

function isCompoundUnits(careLine)
{
	return ((careLine.units.fd > 0 ? 1 : 0) + (careLine.units.hd > 0 ? 1 : 0) + (careLine.units.dd > 0 ? 1 : 0) + (careLine.units.hr > 0 ? 1 : 0)) > 1;
}

// getAge Group
function getAgeGroup(prrType, ageMon, schFlag, onDt)
{
	const result = "Err";
	const tDate = new Date(onDt);
	const myDate = new Date(tDate.getTime() + (tDate.getTimezoneOffset() * 60 * 1000));
	
	const myGrp = AGE_GROUPS_TABLE.find(a => a.prrType === prrType 
	&& ageMon >= a.minMon && ageMon <= a.maxMon && schFlag === (a.schFlag === null ? schFlag : a.schFlag)
	&& myDate >= new Date(new Date(a.begDt) + (tDate.getTimezoneOffset() * 60 * 1000))
	&& myDate <= new Date(new Date(a.endDt) + (tDate.getTimezoneOffset() * 60 * 1000)));
	
	return myGrp ? myGrp.ageGroup : "Error";
}

// resolve a generic type to a specific service code by date
/* generic Types:
	CCFT
	CCPT
	CCSchoolFT
	CCSchoolPT
	CCSleep
	CCOT
	LFHFT
	LFHPT
	LFHSchoolFT
	LFHSchoolFTPartial
	LFHSchoolPT
	LFHSchoolPTPartial
	LFHSleep
	LFHOT
	FFNClHome
	FFNMutHome
	FFNPrrHome
	CCNSHB
	LFHNSHB
*/
function getSvcCodeObj(genType, onDt)
{
	const tDate = new Date(onDt);
	const myDate = new Date(tDate.getTime() + (tDate.getTimezoneOffset() * 60 * 1000));
	
	const myCd = SVC_CODES_TABLE.find(c => c.type === genType 
	&& myDate >= new Date(new Date(c.begDt) + (tDate.getTimezoneOffset() * 60 * 1000))
	&& myDate <= new Date(new Date(c.endDt) + (tDate.getTimezoneOffset() * 60 * 1000)));
	
	return myCd ? {svcCode: myCd.svcCode, desc: myCd.desc } : {svcCode: '0000', desc: 'Code Not Found'}; 
}

// lookup which calculation function to use based on provider type and date
function getCalculationFunction(myType, onDt)
{
	const tDate = new Date(onDt);
	const myDate = new Date(tDate.getTime() + (tDate.getTimezoneOffset() * 60 * 1000));
	
	const myFunc = CALC_FUNCTION_TABLE.find(f => f.type === myType 
	&& myDate >= new Date(new Date(f.begDt) + (tDate.getTimezoneOffset() * 60 * 1000))
	&& myDate <= new Date(new Date(f.endDt) + (tDate.getTimezoneOffset() * 60 * 1000)));
	
	return myFunc ? myFunc.func : 'ERR'; 
}

/* RATES_TABLE: example/possibilities 
prrType: "C", "H", "F"
ageGroup: "Infant", "Toddler", "Enh Toddler", "Pre-School", "School-age", "All"
region: "1","2", "3", "4", "5", "6", "S", "A"
begDt: "2023-07-01"
endDt: "2999-12-31"
unitType: "Full Day", "Half Day", "Hour", "NSHB"
rate: 25.25
*/
function getRate(prrType, ageGroup, region, dtOf, unitType)
{
		const tDate = new Date(dtOf);
		const myDate = new Date(tDate.getTime() + (tDate.getTimezoneOffset() * 60 * 1000));
	
		const myRate = RATES_TABLE.find(r => r.prrType === prrType 
		&& r.ageGroup === ageGroup && r.region === region 
		&& r.unitType === unitType && myDate >= new Date(new Date(r.begDt) + (tDate.getTimezoneOffset() * 60 * 1000))
		&& myDate <= new Date(new Date(r.endDt) + (tDate.getTimezoneOffset() * 60 * 1000)));
		return myRate ? Math.max(myRate.rate, 0) : 0; 
}
		
// get the maximum rate for a specific unit type and provider type as of a specific date
function getMaxRate(prrType, dtOf, unitType)
{
	const tDate = new Date(dtOf);
	const myDate = new Date(tDate.getTime() + (tDate.getTimezoneOffset() * 60 * 1000));

	const myMaxRate = Math.max(0,...RATES_TABLE.filter(r => r.prrType === prrType &&
	 r.unitType === unitType && myDate >= new Date(new Date(r.begDt) + (tDate.getTimezoneOffset() * 60 * 1000))
	&& myDate <= new Date(new Date(r.endDt) + (tDate.getTimezoneOffset() * 60 * 1000))).map(i => i.rate));
	
	return myMaxRate; 
}	

// Schedule functions
function createEmptySchedule(type) 
{
	const schedule = {
		id: getNextScheduleId(),
		type: type,
		weeks: {
			1: {
				Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: []
			}
		}
	};
	
	data.schedules.push(schedule);
	saveData();
	return schedule;
}

function createTempEmptySchedule(type) 
{
	const schedule = {
		id: nextTempScheduleId++,
		type: type,
		weeks: {
			1: {
				Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: []
			}
		}
	};
	return schedule;
}


function refreshScheduleSelector() 
{
	const selector = document.getElementById('scheduleSelector');
	selector.innerHTML = '<option value="">Select a schedule to edit</option>';
	
	if (!data.activeApplicationId) return;
	
	// Add activity schedules
	const activities = data.activities.filter(a => a.applicationId == data.activeApplicationId);
	activities.forEach(activity => {
		const person = data.people.find(p => p.id === activity.personId);
		const option = document.createElement('option');
		option.value = `activity-${activity.scheduleId}`;
		option.textContent = `Activity: ${activity.name} - ${person ? person.name : 'Unknown'}`;
		selector.appendChild(option);
	});
	
	// Add provider link schedules
	const links = data.providerLinks.filter(l => l.applicationId == data.activeApplicationId);
	links.forEach(link => {
		const provider = data.providers.find(p => p.id === link.providerId);
		const person = data.people.find(p => p.id === link.personId);
		const option = document.createElement('option');
		option.value = `link-${link.scheduleId}`;
		option.textContent = `Provider Link: ${provider ? provider.name : 'Unknown'} - ${person ? person.name : 'Unknown'}`;
		selector.appendChild(option);
	});
	loadSchedule();
}

function saveTempSchedule()
{
	if(selectedScheduleId === null)
	{
		alert('Error: No selected schedule found!');
		console.log('Error: No selected schedule found!');
		return;
	}
	const schedule = data.schedules.find(s => s.id === selectedScheduleId);
	if (!schedule) {
		alert('Error: Unable to access the selected schedule!');
		console.log('Error: Unable to access the selected schedule!');
		return;
	}
	schedule.weeks = JSON.parse(JSON.stringify(myTempSchedule.weeks));
	saveData();
	displaySchedule();
	
	alert('Schedule saved.');
	console.log('Schedule saved.');
}

// Loads the selected schedule into myTempSchedule for display and editing
function loadSchedule() 
{
	const selector = document.getElementById('scheduleSelector');
	const editor = document.getElementById('scheduleEditor');
	
	if (!selector.value) {
		editor.style.display = 'none';
		return;
	}
	
	const scheduleId = parseInt(selector.value.split('-')[1]);
	const schedule = data.schedules.find(s => s.id === scheduleId);
	
	if((selectedScheduleId != scheduleId) && (selectedScheduleId != null))
	{
		if(JSON.stringify(myTempSchedule.weeks) != JSON.stringify(data.schedules.find(s => s.id === selectedScheduleId).weeks))
		{
			if (!confirm('There are unsaved changes to the current schedule, are you sure you want to continue?'))
			{
				selector.selectedIndex = mySelectedIndex;
				displaySchedule();
				return;
			}
		}
	}
	
	if (!schedule)
	{
		alert(`Error: Selected schedule [${scheduleId}] does not exist in data.`);
		console.log(`Error: Selected schedule [${scheduleId}] does not exist in data.`);
	}
	else
	{
		mySelectedIndex = selector.selectedIndex;
		selectedScheduleId = scheduleId;
		myTempSchedule.type = schedule.type;
		myTempSchedule.weeks = JSON.parse(JSON.stringify(schedule.weeks));
		
		editor.style.display = 'block';
		updateDayOptions(); // schedule.type);
		updateDefaultButtons(); // schedule);
		displaySchedule(); // schedule);
	}
}

//This function toggles the checkboxes for which days are enabled for a schedule type, based on type the checkBoxes are enabled/disabled
function updateDayOptions() // scheduleType) 
{
	if(!myTempSchedule)
	{
		return;
	}
	const scheduleType = myTempSchedule.type;
	
	document.getElementById('periodError').innerHTML = ''; // clear any existing periodError messages
	
	if(scheduleType === 'S' || scheduleType === 'P')
	{
		document.getElementById('SunBox').checked = false;
		document.getElementById('SunBox').disabled = true;
		document.getElementById('SatBox').checked = false;
		document.getElementById('SatBox').disabled = true;
	}
	else
	{
		document.getElementById('SunBox').checked = false;
		document.getElementById('SunBox').disabled = false;
		document.getElementById('SatBox').checked = false;
		document.getElementById('SatBox').disabled = false;
	}
}

/* removeWeek should use the specified week in the dropdown on the schedule screen to remove that week from the selectedSchedule
 If the specified week doesn't exist in the schedule, do nothing.
 If it is week 1 and there is only one week in the schedule, clear the schedule instead.
 If it is not the last week in the schedule, shift the other weeks down and remove the last week. */
function removeWeek()
{
	const selector = document.getElementById('scheduleSelector');
	if (!selector.value) return;
	
	const scheduleId = selectedScheduleId; // parseInt(selector.value.split('-')[1]);
	const schedule = myTempSchedule; // data.schedules.find(s => s.id === scheduleId);
	
	
	if (!schedule) return;
	const week = parseInt(document.getElementById('periodWeek').value);
	const existingWeeks = Math.max(1, ...Object.keys(schedule.weeks).map(Number).sort((a, b) => a - b));
	document.getElementById('periodError').innerHTML = ''; // clear any existing period error messages
	
	if(week > existingWeeks)
	{
		return;
	}
	if(week === existingWeeks && week === 1) // just clear this week instead
	{
		schedule.weeks = {1: {Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: []}};
	}
	else
	{
		const newObject = {};
		for (const key of Object.keys(schedule.weeks)) 
		{
			if (key < week) 
			{
				newObject[key] = JSON.parse(JSON.stringify(schedule.weeks[key]));
			}
			else if (key > week) 
			{
				newObject[String(key - 1)] = JSON.parse(JSON.stringify(schedule.weeks[key]));
			} 
		}
		schedule.weeks = newObject;
	}
	
	//saveData();
	displaySchedule(); // schedule);
}

function checkDayBoxes(boxNum)
{
	if(!boxNum)
	{
		return;
	}
	document.getElementById('periodError').innerHTML = ''; // remove any current period error messages
	const myDay = document.getElementById(['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][boxNum-1] + 'Box');
	let myCnt = 0;
	['SunBox', 'MonBox', 'TueBox', 'WedBox', 'ThuBox', 'FriBox', 'SatBox'].forEach(d => {
		if(document.getElementById(`${d.toString()}`).checked === true)
		{
			myCnt++;
		}
	});
	if(myCnt <= 0)
	{
		myDay.checked = true;
		console.log('At least one weekday must be specified');
		
	}
}

function modifyBoxes()
{
	['SunBox', 'MonBox', 'TueBox', 'WedBox', 'ThuBox', 'FriBox', 'SatBox'].forEach(d => {
		document.getElementById(`${d.toString()}`).checked = false;});
}

function getCheckBoxRes()
{
	let myCnt = 0;
	['SunBox', 'MonBox', 'TueBox', 'WedBox', 'ThuBox', 'FriBox', 'SatBox'].forEach(d => {
		if(document.getElementById(`${d.toString()}`).checked === true)
		{
			myCnt++;
		}
	});
	return myCnt;
}

 
function updateDefaultButtons() // schedule)
{
	const schedule = myTempSchedule;
	
	if(!schedule)
	{
		return;
	}
	const editor = document.getElementById('scheduleEditorButtons');
	
	// Remove existing default buttons
	const existingButtons = editor.querySelectorAll('.default-schedule-btn');
	existingButtons.forEach(btn => btn.remove());
	
	// Add default schedule buttons
	const buttonContainer = document.createElement('div');
	buttonContainer.style.marginBottom = '15px';
	
	// Add Week button
	const addWeekBtn = document.createElement('button');
	addWeekBtn.textContent = 'Add New Week';
	addWeekBtn.id = "addWeekButton";
	addWeekBtn.className = 'default-schedule-btn';
	addWeekBtn.onclick = () => addNewWeek();
	buttonContainer.appendChild(addWeekBtn);
	
	// Remove Selected Week button
	const remWeekBtn = document.createElement('button');
	remWeekBtn.textContent = 'Remove Week';
	remWeekBtn.id = 'remWeekButton';
	remWeekBtn.className = 'default-schedule-btn';
	remWeekBtn.onclick = () => removeWeek();
	buttonContainer.appendChild(remWeekBtn);

	
	// M-F 8a-5p button
	const btn1 = document.createElement('button');
	btn1.textContent = 'M-F 8a-5p';
	btn1.className = 'default-schedule-btn';
	btn1.onclick = () => loadDefaultSchedule('8a-5p');
	buttonContainer.appendChild(btn1);
	
	// M-F 7:30a-5:30p button
	const btn2 = document.createElement('button');
	btn2.textContent = 'M-F 7:30a-5:30p';
	btn2.className = 'default-schedule-btn';
	btn2.onclick = () => loadDefaultSchedule('730a-530p');
	buttonContainer.appendChild(btn2);
	
	// M-F 8:30a-3:30p button (only shows for school type schedules or provider-child link schedules
	if (schedule.type === 'R' || schedule.type === 'N'|| schedule.type === 'S'|| schedule.type === 'P') {
	const btn3 = document.createElement('button');
	btn3.textContent = 'M-F 8:30a-3:30p';
	btn3.className = 'default-schedule-btn';
	btn3.onclick = () => loadDefaultSchedule('830a-330p');
	buttonContainer.appendChild(btn3);
	}
	
	 // M-F 8a-3p button (only shows for school type schedules or provider-child link schedules
	if (schedule.type === 'R' || schedule.type === 'N'|| schedule.type === 'S'|| schedule.type === 'P') {
	const btn4 = document.createElement('button');
	btn4.textContent = 'M-F 8a-3p';
	btn4.className = 'default-schedule-btn';
	btn4.onclick = () => loadDefaultSchedule('8a-3p');
	buttonContainer.appendChild(btn4);
	}
	
	// 24/7 button (only for provider-child link schedules or child nocare schedules)
	if (schedule.type === 'R' || schedule.type === 'N') {
		const btn5 = document.createElement('button');
		btn5.textContent = '24/7';
		btn5.className = 'default-schedule-btn';
		btn5.onclick = () => loadDefaultSchedule('24-7');
		buttonContainer.appendChild(btn5);
	}
	
	// Insert into the button section
	editor.appendChild(buttonContainer);
}

function addNewWeektoSch(schedule)
{
	const existingWeeks = Object.keys(schedule.weeks).map(Number).sort((a, b) => a - b);
	const nextWeek = Math.max(...existingWeeks) + 1;
	
	if(isNaN(nextWeek))
	{
		return;
	}
	
	if (nextWeek > 4) {
		alert('Maximum of 4 weeks allowed in a schedule');
		console.log('Maximum of 4 weeks allowed in a schedule');
		return;
	}
	
	// Add the new week
	schedule.weeks[nextWeek] = {
		Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: []
	};
}

// Adds a new week to the end of the current schedule for myTempSchedule
function addNewWeek() 
{
	const selector = document.getElementById('scheduleSelector');
	if (!selector.value) return;
	
	const scheduleId = selectedScheduleId; // parseInt(selector.value.split('-')[1]);
	const schedule = myTempSchedule; //data.schedules.find(s => s.id === scheduleId);
	if (!schedule) return;
	
	// Find the next available week number
	const existingWeeks = Object.keys(schedule.weeks).map(Number).sort((a, b) => a - b);
	const nextWeek = Math.max(...existingWeeks) + 1;
	
	if (nextWeek > 4) {
		alert('Maximum of 4 weeks allowed in a schedule');
		console.log('Maximum of 4 weeks allowed in a schedule');
		return;
	}
	
	// Add the new week
	schedule.weeks[nextWeek] = {
		Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: []
	};
	
	//saveData();
	displaySchedule(); // schedule);
	
	alert(`Week ${nextWeek} added to schedule`);
	console.log(`Week ${nextWeek} added to schedule`);
}

/* This function should load the requested default schedule type into the week selected by the user on the schedule 
	screen without modifying any other weeks in the existing schedule, but adding the week(s) up to the seclected week if it does not exist yet. */
	// Uses the myTempSchedule item
function loadDefaultSchedule(type) 
{
	const selector = document.getElementById('scheduleSelector');
	if (!selector.value) return;
	
	const scheduleId = selectedScheduleId; // parseInt(selector.value.split('-')[1]);
	const schedule = myTempSchedule; // data.schedules.find(s => s.id === scheduleId);
	if (!schedule) return;
	
	const week = parseInt(document.getElementById('periodWeek').value);
	const existingWeeks = Math.max(1, ...Object.keys(schedule.weeks).map(Number).sort((a, b) => a - b));
	
	//if the specified week is less than the maximum week, add blank weeks to the maximum
	if(week > existingWeeks)
	{
		for(let i = existingWeeks; i < week; i++)
		{
			addNewWeektoSch(schedule);
		}
	}
	
	// Clear existing schedule for the selected week
	schedule.weeks[week] = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };
	
	// populate the selected week with the requested schedule, should probably use a switch here
	
	if (type === '8a-5p') {
		// M-F 8:00 AM - 5:00 PM (480-1020)
		['Mon', 'Tue', 'Wed', 'Thu', 'Fri'].forEach(day => {
			schedule.weeks[week][day].push({ 
				start: 480, 
				end: 1020, 
				type: schedule.type 
			});
		});
	} else if (type === '730a-530p') {
		// M-F 7:30 AM - 5:30 PM (450-1050)
		['Mon', 'Tue', 'Wed', 'Thu', 'Fri'].forEach(day => {
			schedule.weeks[week][day].push({ 
				start: 450, 
				end: 1050, 
				type: schedule.type 
			});
		});
	} else if (type === '830a-330p') {
		// M-F 8:30 AM - 3:30 PM (510-930)
		['Mon', 'Tue', 'Wed', 'Thu', 'Fri'].forEach(day => {
			schedule.weeks[week][day].push({ 
				start: 510, 
				end: 930, 
				type: schedule.type 
			});
		});
	} else if (type === '8a-3p') {
		// M-F 8 AM - 3 PM (480-900)
		['Mon', 'Tue', 'Wed', 'Thu', 'Fri'].forEach(day => {
			schedule.weeks[week][day].push({ 
				start: 480, 
				end: 900, 
				type: schedule.type 
			});
		});
	} else if (type === '24-7') {
		// 24/7 12:00 AM - 12:00 AM (0-1440)
		['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].forEach(day => {
			schedule.weeks[week][day].push({ 
				start: 0, 
				end: 1440, 
				type: schedule.type 
			});
		});
	}
	
	//saveData();
	displaySchedule(); //schedule);
}

// Calculate Care functions
function refreshCalculationForm() 
{
	const form = document.getElementById('calculationForm');
	
	if (!data.activeApplicationId) {
		form.innerHTML = '<p>Please select an active application first.</p>';
		return;
	}
	
	const app = data.applications.find(a => a.id == data.activeApplicationId);
	if (!app) {
		form.innerHTML = '<p>Active application not found.</p>';
		return;
	}
	
	form.innerHTML = `
		<p>Active Application: ${data.activeApplicationId}</p>
		<p>Ready to calculate care for all children in this application.</p>
<p><label>Care Start Date:</label><input type="date" id="careStartDate"></p>
		<button onclick="calculateCurrentCare()" style="background: #28a745; font-size: 16px; padding: 15px 30px;">Calculate All Care</button>
	`;
	document.getElementById('calculationResults').innerHTML = '<p>No calculation performed yet.</p>';
}

function displaySchedule() // schedule) 
{
	const schedule = myTempSchedule;
	const refSchedule = data.schedules.find(s => s.id === selectedScheduleId);
	if(!myTempSchedule)
	{
		myTempSchedule = createTempEmptySchedule('A');
	}
	const saveButton = document.getElementById('saveChangesButton');
	saveButton.style.visibility = 'hidden';
	saveButton.style.display = 'none';
	
	if(selectedScheduleId != null && refSchedule)
	{
		if(JSON.stringify(schedule.weeks) != JSON.stringify(refSchedule.weeks))
		{
			// show the save changes button
			saveButton.style.visibility = 'visible';
			saveButton.style.display = 'inline-block';
		}
	}
	
	const display = document.getElementById('scheduleDisplay');
	
	// Create 5x8 grid (weeks + 7 days)
	let html = '<div class="schedule-grid">';
	
	// Header row
	html += '<div class="schedule-cell schedule-header">Week</div>';
	['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'].forEach(day => {
		html += `<div class="schedule-cell schedule-header">${day}</div>`;
	});
	
	// Week rows (always show 4 weeks)
	for (let week = 1; week <= 4; week++) {
		const weekExists = schedule.weeks[week] !== undefined;
		const weekClass = weekExists ? '' : ' empty-week';
		
		html += `<div class="schedule-cell schedule-header${weekClass}">Week ${week}</div>`;
		
		['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].forEach(day => {
			html += `<div class="schedule-cell${weekClass}">`;
			
			if (weekExists && schedule.weeks[week][day]) {
				const periods = schedule.weeks[week][day].sort((a, b) => a.start - b.start);
				periods.forEach(period => {
					html += `<div class="period" onclick="removePeriod(${schedule.id}, ${week}, '${day}', ${period.start}, ${period.end})">${formatTime(period.start)} - ${formatTime(period.end)}</div>`;
				});
			}
			
			html += '</div>';
		});
	}
	
	html += '</div>';
	display.innerHTML = html;
}

// Clears the schedule in the myTempSchedule object
function clearSchedule() 
{
	const selector = document.getElementById('scheduleSelector');
	if (!selector.value) return;
	
	if (!confirm('Are you sure you want to clear this schedule?')) return;
	
	const scheduleId = parseInt(selector.value.split('-')[1]);
	const schedule = data.schedules.find(s => s.id === scheduleId);
	document.getElementById('periodError').innerHTML = '';
	
	if (schedule) {
		schedule.weeks = {
			1: {
				Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: []
			}
		};
		saveData();
		displaySchedule(schedule);
	}
        }
		
function getTimeString(which)
{
	const regex = /[^0-9]/g;
	const hr = document.getElementById(which+'Hr').value;
	const minEle = document.getElementById(which+'Mins');
	minEle.value = minEle.value.replace(regex, '0');
	const mins = minEle.value;
	const apm = document.getElementById(which+'APM').value;
	
	return hr + ':' + ('00' + mins).slice(-2) + ' ' +apm;
}

// Should add period to the selected week of the selected schedule for each day checkbox selected
// Uses the myTempSchedule object
function addPeriods()
{
	if(getCheckBoxRes() === 0)
	{
		alert('At least one weekday must be specified!');
		console.log('At least one weekday must be specified!');
		return;
	}
	const selector = document.getElementById('scheduleSelector');
	if (!selector.value) return;
	
	const scheduleId = selectedScheduleId; // parseInt(selector.value.split('-')[1]);
	const schedule = myTempSchedule; // data.schedules.find(s => s.id === scheduleId);
	if (!schedule) return;
	
	const startTimeStr = getTimeString('start');
	const endTimeStr = getTimeString('end');
	
	document.getElementById('periodError').innerHTML = '';
	
	let startTime = parseTime(startTimeStr);
	let endTime = parseTime(endTimeStr);
	let haveIssue = false;
	
	if (startTime === null) {
		document.getElementById('periodError').innerHTML += '<p>Invalid start time format. Use H:mm AM/PM</p>';
		console.log('Invalid start time format. Use H:mm AM/PM');
		haveIssue = true;
	}
	
	if (endTime === null) {
		document.getElementById('periodError').innerHTML += '<p>Invalid end time format. Use H:mm AM/PM</p>';
		console.log('Invalid end time format. Use H:mm AM/PM');
		haveIssue = true;
	}
	if(haveIssue)
	{
		return;
	}

	['SunBox', 'MonBox', 'TueBox', 'WedBox', 'ThuBox', 'FriBox', 'SatBox'].forEach(d => {
		if(document.getElementById(`${d.toString()}`).checked === true)
		{
			addPeriod(d.toString().substring(0,3));
		}
	});
	
	 // Clear form
	modifyBoxes();
	
	//saveData();
	displaySchedule(); //schedule);
}

// adds the specified period to a specific day in the specified week
// Uses the myTempSchedule object
function addPeriod(day) 
{
	const selector = document.getElementById('scheduleSelector');
	if (!selector.value) return;
	
	const scheduleId = selectedScheduleId;// parseInt(selector.value.split('-')[1]);
	const schedule = myTempSchedule; // data.schedules.find(s => s.id === scheduleId);
	if (!schedule) return;
	
	const week = parseInt(document.getElementById('periodWeek').value);
	const startTimeStr = getTimeString('start');
	const endTimeStr = getTimeString('end');
	
	document.getElementById('periodError').innerHTML = '';
	
	let startTime = parseTime(startTimeStr);
	let endTime = parseTime(endTimeStr);
	let haveIssue = false;
	
	if (startTime === null) {
		document.getElementById('periodError').innerHTML += '<p>Invalid start time format. Use H:mm AM/PM</p>';
		console.log('Invalid start time format. Use H:mm AM/PM');
		haveIssue = true;
	}
	
	if (endTime === null) {
		document.getElementById('periodError').innerHTML += '<p>Invalid end time format. Use H:mm AM/PM</p>';
		console.log('Invalid end time format. Use H:mm AM/PM');
		haveIssue = true;
	}
	if(haveIssue)
	{
		return;
	}
	
	// Special handling for 12:00 AM as end time - treat as end of day (1440)
	if (endTimeStr.match(/^12:00\s*AM$/i)) {
		endTime = 1440;
	}
	
	// Ensure the target week exists, and create any missing weeks up to it
	ensureWeeksExist(schedule, week);
	
	// Adding period shouldn't ever fail anymore, overlapping periods become merged now.
	
	// Handle periods that cross midnight (end time is next day)
	if (endTime <= startTime && endTime !== 1440) {
		// This is an overnight period, split it
		
		// First period: start time to midnight on current day
		if (!addPeriodToSchedule(schedule, week, day, startTime, 1440)) {
			return; // Error already set
		}
		
		// Second period: midnight to end time on next day
		const nextDay = getNextDay(day);
		let nextWeek = week;
		
		if (day === 'Sat') {
			// For Saturday overflow, find the next existing Sunday
			const existingWeeks = Object.keys(schedule.weeks).map(Number).sort((a, b) => a - b);
			const nextExistingWeek = existingWeeks.find(w => w > week);
			nextWeek = nextExistingWeek || 1; // Use next existing week or wrap to week 1
		}
		if (!addPeriodToSchedule(schedule, nextWeek, nextDay, 0, endTime)) {
			// If second period fails, remove the first period we just added
			schedule.weeks[week][day].pop();
			return;
		}
	} else {
		// Normal period within same day
		if (!addPeriodToSchedule(schedule, week, day, startTime, endTime)) {
			return; // Error already set by addPeriodToScehdule
		}
	}
}

function ensureWeeksExist(schedule, targetWeek) 
{
	// Create all weeks up to the target week if they don't exist
	for (let w = 1; w <= targetWeek; w++) {
		if (!schedule.weeks[w]) {
			schedule.weeks[w] = {
				Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: []
			};
		}
	}
}

function getNextDay(day) 
{
	const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	const index = days.indexOf(day);
	return days[(index + 1) % 7];
}

function addPeriodToSchedule(schedule, week, day, startTime, endTime) 
{
	// Ensure week exists
	ensureWeeksExist(schedule, week);
	
	// Check for overlaps
	const existingPeriods = schedule.weeks[week][day];
	for (let period of existingPeriods) {
		if ((endTime >= period.start) && (startTime <= period.end)) // Overlaps with existing period.
		{
			document.getElementById('periodError').innerHTML += `<p>Warning: Period overlapped with existing period in ${day} of week ${week}.</p>`;
			console.log(`Warning: Period overlapped with existing period in ${day} of week ${week}.`);
			// return false;
			if(startTime < period.start)
			{
				period.start = startTime;
			}
			if(endTime > period.end)
			{
				period.end = endTime;
			}
			return true;
		}
	}
	
	// Add period with type matching the schedule type
	existingPeriods.push({ 
		start: startTime, 
		end: endTime, 
		type: schedule.type 
	});
	return true;
}

// Uses the myTempSchedule object
function removePeriod(scheduleId, week, day, startTime, endTime) 
{
	if (!confirm('Remove this period?')) return;
	document.getElementById('periodError').innerHTML = '';
	
	const schedule = myTempSchedule; // data.schedules.find(s => s.id === scheduleId);
	if (!schedule || !schedule.weeks[week]) return;
	
	schedule.weeks[week][day] = schedule.weeks[week][day].filter(p => 
		!(p.start === startTime && p.end === endTime));
	
	//saveData();
	displaySchedule(); // schedule);
}

// new functions for schedule compression and decompression

// Convert schedule to compressed string format
function scheduleToCompressedString(schedule) 
{
    const weekCount = getScheduleWeekCount(schedule);
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    // Start with week count and schedule type
    let result = weekCount.toString() + schedule.type;
    
    // Create a map to group identical periods across days
    const periodGroups = new Map();
    
    // Collect all periods and group by time range
    for (let week = 1; week <= weekCount; week++) {
        for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
            const dayName = dayNames[dayIndex];
            const dayChar = String.fromCharCode(64 + (week - 1) * 7 + dayIndex); // '@' + offset
            
            const periods = schedule.weeks[week] && schedule.weeks[week][dayName] ? schedule.weeks[week][dayName] : [];
                
            periods.forEach(period => {
                const periodKey = `${period.start}:${period.end}`;
                if (!periodGroups.has(periodKey)) {
                    periodGroups.set(periodKey, []);
                }
                periodGroups.get(periodKey).push({
                    dayChar: dayChar,
                    week: week,
                    dayIndex: dayIndex
                });
            });
        }
    }
    
    // Process each period group
    for (let [periodKey, days] of periodGroups) 
	{
        if (days.length === 0) continue;
        
        // Sort days by their character code (chronological order)
        days.sort((a, b) => a.dayChar.charCodeAt(0) - b.dayChar.charCodeAt(0));
        
        // Group consecutive days
        const dayGroups = [];
        let currentGroup = [days[0]];
        
        for (let i = 1; i < days.length; i++) 
		{
            const prevCode = days[i-1].dayChar.charCodeAt(0);
            const currentCode = days[i].dayChar.charCodeAt(0);
            
            if (currentCode === prevCode + 1) // Consecutive day
			{
                currentGroup.push(days[i]);
            } 
			else // Gap found, start new group
			{
                dayGroups.push(currentGroup);
                currentGroup = [days[i]];
            }
        }
        dayGroups.push(currentGroup);
        
        // Format day groups
        const dayGroupStrings = dayGroups.map(group => 
		{
            if (group.length >= 4) // Use range notation for 4+ consecutive days
			{
                return group[0].dayChar + '-' + group[group.length - 1].dayChar;
            } 
			else // List individual days for 3 or fewer 
			{
                return group.map(d => d.dayChar).join('');
            }
        });
        
        // Add to result
        result += dayGroupStrings.join('') + periodKey;
        
        const remainingGroups = Array.from(periodGroups.entries()).slice(Array.from(periodGroups.keys()).indexOf(periodKey) + 1);
		// Add comma if this isn't the last period group
        if (remainingGroups.length > 0) 
		{
            result += ',';
        }
    }
    
    return result;
}

// Convert compressed string back to schedule object
function compressedStringToSchedule(compressedString) 
{ 
    const weekCount = Math.min(4,parseInt(compressedString[0])); // always 1-4
    const scheduleType = compressedString[1];
    const periodsString = compressedString.slice(2);
	const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    // Initialize empty schedule
    const schedule = createTempEmptySchedule(scheduleType);
    
    for (let week = 1; week < weekCount; week++) 
	{
        addNewWeektoSch(schedule);
    }
    
    if (periodsString.length === 0) 
	{
        return schedule; // Empty schedule
    }
    
    // Split by commas to get individual period groups
    const periodGroups = periodsString.split(',');
    
    for (let group of periodGroups) 
	{
        if (!group) continue;
        
        // Find the time specification (last occurrence of digit:digit pattern)
        const timeMatch = group.match(/(\d+):(\d+)$/); 
        const startTime = parseInt(timeMatch[1]);
        const endTime = parseInt(timeMatch[2]);
        const dayPart = group.slice(0, group.length - timeMatch[0].length);
        
        // Parse day specifications
        const dayChars = parseDaySpecification(dayPart);
        
        // Add periods to appropriate days
        dayChars.forEach(dayChar => 
		{
            const charCode = dayChar.charCodeAt(0);
            const offset = charCode - 64; // '@' is 64
            const week = Math.floor(offset / 7) + 1;
            const dayIndex = offset % 7;        
            const dayName = dayNames[dayIndex];
			
            schedule.weeks[week][dayName].push({
                start: startTime,
                end: endTime,
                type: scheduleType
            });
        });
    }
    
    return schedule;
}

// function to parse day specifications
function parseDaySpecification(daySpec) 
{
    const dayChars = [];
    let i = 0;
    
    while (i < daySpec.length) 
	{
        const currentChar = daySpec[i];
        
        // Check if this is a range (next character is '-')
        if (i + 2 < daySpec.length && daySpec[i + 1] === '-') {
            const startChar = currentChar;
            const endChar = daySpec[i + 2];
            const startCode = startChar.charCodeAt(0);
            const endCode = endChar.charCodeAt(0);
            
            // Add all characters in range
            for (let code = startCode; code <= endCode; code++) 
			{
                dayChars.push(String.fromCharCode(code));
            }
            i += 3; // Skip start, dash, and end
        } 
		else // Individual day character 
		{
            dayChars.push(currentChar);
            i++;
        }
    }
    
    return dayChars;
}

// formats a date into a string MM/DD/YYYY
function getFormattedDate(dateStr) 
{
  let tdate = new Date(dateStr);
  let date = new Date(tdate.getTime() + (tdate.getTimezoneOffset() * 60 * 1000));
  var year = date.getFullYear();

  var month = (1 + date.getMonth()).toString();
  month = month.length > 1 ? month : '0' + month;

  var day = date.getDate().toString();
  day = day.length > 1 ? day : '0' + day;
  
  return month + '/' + day + '/' + year;
}

// to get childs age in months as of a care begin date, call calculateCompleteMonths(birthdate, carebegindate)
function calculateCompleteMonths(startDate, endDate) 
{
  // Convert string dates to Date objects if needed
  const tStart = new Date(startDate);
  const tEnd = new Date(endDate);
  
  const conStart = new Date(tStart.getTime() + (tStart.getTimezoneOffset() * 60 * 1000));
  const conEnd = new Date(tEnd.getTime() + (tEnd.getTimezoneOffset() * 60 * 1000));

  const start = new Date(conStart.getFullYear(), conStart.getMonth(), 1);
  const end = new Date(conEnd.getFullYear(), conEnd.getMonth(),0);

  if (start >= end) 
  {
    return 0;
  }
  
  // Calculate the difference in months
  let months = 0;
  let currentDate = new Date(start.getFullYear(), start.getMonth() + 1, 1);
  
  // Count complete months until we reach or pass the target month
  while (currentDate <= end) 
  {
    months++;
    currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
  }
  
  return months;
}

/* Authorization Calculation Functions
 Each function accepts a calculationResult object and a non9CodedTotal (remaining number of hours of care that can possible be 9 coded for a child)
 Each function returns a careResult object that contains an array of authLines, an array of summerAuthLines, and a summerChg flag
*/

// Monthly Unit Type Authorizations
function determineMonthlyAuthorizations(calculationResult, non9CodeRemain)
{
	let summerChg = false;
	const authLines = [];
	const summerLines = [];
	
	if(Math.max(calculationResult.totalTime, calculationResult.SummerTotalTime) > 0.0)
	{
		let xCode = '0';
		let myUnits = 0;
		let myRate = 0;
		let mySummerUnits = 0;
		let mySummerRate = 0;
		let myFDRate = getRate(calculationResult.providerType,getAgeGroup(calculationResult.providerType, calculationResult.ageMonths, calculationResult.schoolAge, calculationResult.startDate),calculationResult.region, calculationResult.startDate, "Full Day");
		let myHDRate = getRate(calculationResult.providerType,getAgeGroup(calculationResult.providerType, calculationResult.ageMonths, calculationResult.schoolAge, calculationResult.startDate),calculationResult.region, calculationResult.startDate, "Half Day");
		let myPDRate = parseFloat(Number(myFDRate*.75).toFixed(2));
		let myBaseType = calculationResult.providerType === 'C' ? 'CC' : 'LFH';
		let myType = myBaseType;
		let totalAuthd = 0; // HDU equivalent
		let totalSummerAuthd = 0; // HDU Equivalent
		let targetAuth = ((calculationResult.fullDays * 2) + (calculationResult.partialDays * 1.5) + calculationResult.halfDays); // HDU Equivalent
		let targetSummerAuth = Math.max(targetAuth, ((calculationResult.SummerFullDays * 2) + (calculationResult.SummerPartialDays * 1.5) +calculationResult.SummerHalfDays)); // HDU Equivalent
		let sleepRemain = Math.ceil((Math.max(calculationResult.sleepTime,calculationResult.SummerSleepTime)/300.0)); // max HDU attributable to sleep time
		let amntDue = ((myFDRate * calculationResult.fullDays) + (myHDRate * calculationResult.halfDays) + (myPDRate * calculationResult.partialDays)); // Minimum amount to be authorized in $$'s
		let summerAmntDue = ((myFDRate * calculationResult.SummerFullDays) + (myHDRate * calculationResult.SummerHalfDays) + (myPDRate * calculationResult.SummerPartialDays));
		let amntAuthd = 0; // amnt authorized in $$'s
		let summerAmntAuthd = 0;
		let myExcess = 0;
		let mySummerExcess = 0;
		// equivalent care authorized in each round
		let eqFD = 0; 
		let eqPD = 0;
		let eqHD = 0;
		let SeqFD = 0;
		let SeqPD = 0;
		let SeqHD = 0;
		let myMsg = '';
		
		// first do the base unit, then the rest (if any) are 9 coded overtime types only (Sleep or OT) based only on remaining HDUs and any difference in total equivalent amount
		myType = myBaseType;
		xCode = (((calculationResult.multProvs && !calculationResult.isPrimary) || (Math.max(summerLines.length, authLines.length) > 1)) ? '9' : '0');
		if(xCode === '9') // the base type can only be PT, SchoolPT, or SchoolPTPartial
		{
			if(calculationResult.schoolAge && calculationResult.schoolOverlap)
			{
				myType += 'SchoolPT';
				if((calculationResult.initSchoolPartDays > 0) && (calculationResult.initSchoolPartDays >= (calculationResult.initSchoolMFHalfDays - calculationResult.initSchoolPartDays)))
				{
					myType += 'Partial';
				}
			}
			else
			{
				myType += 'PT';
			}
			if(targetAuth <= 44) // everything can fit in one unit
			{
				eqFD = calculationResult.fullDays;
				eqHD = calculationResult.halfDays;
				eqPD = calculationResult.partialDays;
				if(targetSummerAuth <= 44)
				{
					SeqFD = calculationResult.SummerFullDays;
					SeqHD = calculationResult.SummerHalfDays;
					SeqPD = calculationResult.SummerPartialDays;
					if ((targetSummerAuth != targetAuth) || (summerAmntDue != amntDue))
					{
						summerChg = true;
					}
				}
				else // maximum of 44 HDU can fit in this unit, authorize equivalent to 44 HDU/22 FDU
				{
					SeqHD = 44;
					summerChg = true;
				}
			}
			else // max of 44 HDU can fit in this unit, authorize equivalent to 44 HDU/22 FDU
			{
				eqHD = 44;
				SeqHD = 44;
			}
			if(Math.max(((eqFD*10) + ((eqHD + eqPD)*5)),((SeqFD*10) + ((SeqHD + SeqPD)*5))) <= non9CodeRemain) // If all equivalent care is less than the remaining limit before care must be authorized, the unit doesn't need to be 9 coded.
			{
				xCode = '0';
			}
		}
		// BASE TYPES: FT, PT, SchoolFT, SchoolPT, SchoolFTPartial, SchoolPTPartial
		else // This is the primary or only provider, could be any base type, is 0 coded, all 110 rules apply.
		{
			if((targetAuth > 44) || ((calculationResult.care110) && (calculationResult.initSchoolFullDays > 0))) // can only be FT or SchoolPT Equivalent to full time 22 FDU
			{
				myType += calculationResult.schoolOverlap ? 'SchoolPT' : 'FT';
				eqFD = 22;
				SeqFD = 22;
				if(calculationResult.targetAuth < 44)
				{
					myMsg = 'Equivalent to full time care.'
				}
			}
			else if(calculationResult.meets110) // family meets 110 rule.
			{
				if(calculationResult.schoolAge && calculationResult.schoolOverlap) // school aged child
				{
					if(calculationResult.summ110) // meets 110 hours of care in summer
					{
						// care is either SchoolFT or SchoolFTPartial if less than preset values, otherwise SchoolPT or SchoolPTPartial
						if(calculationResult.fullDays <= 5 && calculationResult.partialDays <= 17 && calculationResult.halfDays === 0)
						{
							myType += 'SchoolFTPartial';
							eqFD = 5;
							eqHD = 0;
							eqPD = 17;
							SeqFD = 22;
							SeqHD = 0;
							SeqPD = 0;
						}
						else if(calculationResult.fullDays <= 5 && calculationResult.partialDays === 0 && calculationResult.halfDays <= 17)
						{
							myType += 'SchoolFT';
							eqFD = 5;
							eqHD = 17;
							eqPD = 0;
							SeqFD = 22;
							SeqHD = 0;
							SeqPD = 0;
						}
						else
						{
							myType += 'SchoolPT';
							if(calculationResult.partialDays > 0)
							{
								myType += 'Partial';
							}
							eqFD = calculationResult.fullDays;
							eqPD = calculationResult.partialDays;
							eqHD = calculationResult.halfDays;
							if(targetSummerAuth >= 44)
							{
								SeqFD = 0;
								SeqPD = 0;
								SeqHD = 44;
							}
							else
							{
								SeqFD = calculationResult.SummerFullDays;
								SeqPD = calculationResult.SummerPartialDays;
								SeqHD = calculationResult.SummerHalfDays;
							}
							if((((eqFD*2)+(eqPD*1.5)+(eqHD)) < ((SeqFD*2)+(SeqPD*1.5)+(SeqHD))) || (((eqFD * myFDRate)+(eqPD*myPDRate)+(eqHD*myHDRate)) < ((SeqFD * myFDRate)+(SeqPD*myPDRate)+(SeqHD*myHDRate))))
							{
								summerChg = true;
							}
						}
					}
					else // school aged child without 110hr summer care, only eligible for SchoolPT or SchoolPTPartial
					{
						myType += 'SchoolPT';
						if(calculationResult.partialDays > 0)
						{
							myType += 'Partial';
						}
						eqFD = calculationResult.fullDays;
						eqPD = calculationResult.partialDays;
						eqHD = calculationResult.halfDays;
						if(targetSummerAuth >= 44)
						{
							SeqFD = 0;
							SeqPD = 0;
							SeqHD = 44;
						}
						else
						{
							SeqFD = calculationResult.SummerFullDays;
							SeqPD = calculationResult.SummerPartialDays;
							SeqHD = calculationResult.SummerHalfDays;
						}
						if((((eqFD*2)+(eqPD*1.5)+(eqHD)) < ((SeqFD*2)+(SeqPD*1.5)+(SeqHD))) || (((eqFD * myFDRate)+(eqPD*myPDRate)+(eqHD*myHDRate)) < ((SeqFD * myFDRate)+(SeqPD*myPDRate)+(SeqHD*myHDRate))))
						{
							summerChg = true;
						}
					}
				}
				else if (calculationResult.care110) // not considered a school-aged child, family meets 110 and care is 110 FT care
				{
					myType += 'FT';
					eqFD = 22;
					SeqFD = 22;
				}
				else // care is PT and is based on the care needed
				{
					myType += 'PT';
					eqFD = calculationResult.fullDays;
					eqPD = calculationResult.partialDays;
					eqHD = calculationResult.halfDays;
					if(targetSummerAuth >= 44)
					{
						SeqFD = 0;
						SeqPD = 0;
						SeqHD = 44;
					}
					else
					{
						SeqFD = calculationResult.SummerFullDays;
						SeqPD = calculationResult.SummerPartialDays;
						SeqHD = calculationResult.SummerHalfDays;
					}
					if((((eqFD*2)+(eqPD*1.5)+(eqHD)) < ((SeqFD*2)+(SeqPD*1.5)+(SeqHD))) || (((eqFD * myFDRate)+(eqPD*myPDRate)+(eqHD*myHDRate)) < ((SeqFD * myFDRate)+(SeqPD*myPDRate)+(SeqHD*myHDRate))))
					{
						summerChg = true;
					}
				}
			}
			else // care is based only on what the child needs, must be either PT, SchoolPT, or SchoolPTPartial unit
			{
				if(calculationResult.schoolAge && calculationResult.schoolOverlap)
				{
					myType+= 'SchoolPT';
					if(calculationResult.partialDays > 0)
					{ 
						myType += 'Partial';
					}
				}
				else
				{
					myType += 'PT';
				}
				eqFD = calculationResult.fullDays;
				eqPD = calculationResult.partialDays;
				eqHD = calculationResult.halfDays;
				if(targetSummerAuth >= 44)
				{
					SeqFD = 0;
					SeqPD = 0;
					SeqHD = 44;
				}
				else
				{
					SeqFD = calculationResult.SummerFullDays;
					SeqPD = calculationResult.SummerPartialDays;
					SeqHD = calculationResult.SummerHalfDays;
				}
				if((((eqFD*2)+(eqPD*1.5)+(eqHD)) != ((SeqFD*2)+(SeqPD*1.5)+(SeqHD))) || (((eqFD * myFDRate)+(eqPD*myPDRate)+(eqHD*myHDRate)) != ((SeqFD * myFDRate)+(SeqPD*myPDRate)+(SeqHD*myHDRate))))
				{
					summerChg = true;
				}
			}
		}
		
		// Add the base unit line
		myRate = ((myFDRate * eqFD) + (myHDRate * eqHD) + (myPDRate * eqPD));
		mySummerRate = ((myFDRate * SeqFD) + (myHDRate * SeqHD) + (myPDRate * SeqPD));
		authLines.push({type: myType, xCode: xCode, authUnits: 1, amt: myRate, units: {fd: eqFD, hd: eqHD, pd: eqPD, hr: 0}, excess: 0, inc: true, msg: myMsg, rates:{fd: myFDRate, hd: myHDRate, pd: myPDRate, hr: 0}});
		summerLines.push({type: myType, xCode: xCode, authUnits: 1, amt: mySummerRate, units: {fd: SeqFD, hd: SeqHD, pd: SeqPD, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: myFDRate, hd: myHDRate, pd: myPDRate, hr: 0}});
		
		totalAuthd += ((eqFD * 2) + (eqPD*1.5) + eqHD);
		totalSummerAuthd += ((SeqFD * 2) + (SeqPD*1.5) + SeqHD);
		amntAuthd += myRate;
		summerAmntAuthd += mySummerRate;
		// first line added
		
		// set up additional OT lines if any
		while((totalAuthd < targetAuth) && (totalSummerAuthd < targetSummerAuth) && (amntAuthd < amntDue) && (summerAmntAuthd < summerAmntDue))
		{
			eqFD = 0;
			eqPD = 0;
			SeqPD = 0;
			SeqFD = 0;
			myExcess = 0;
			mySummerExcess = 0;
			
			eqHD = Math.min(44,Math.max(0,Math.floor(targetAuth - totalAuthd)));
			SeqHD = Math.min(44,Math.max(0,Math.floor(targetSummerAuth - totalSummerAuthd)));
			
			myType = myBaseType + (sleepRemain > 0 ? 'Sleep' : 'OT');
			xCode = '9';
			if(sleepRemain > 0)
			{
				eqHD = Math.max(0,Math.min(44, sleepRemain, eqHD));
				SeqHD = Math.min(44, sleepRemain, SeqHD);
				sleepRemain -= Math.max(eqHD, SeqHD);
			}
			// if under 44 units, and no additional lines remain check if there is any excess care that must be included, that will fit in this authorization
			if((eqHD < 44) && (totalAuthd + eqHD >= Math.floor(targetAuth)))
			{
				if(((amntAuthd + (eqHD * myHDRate)) < amntDue) && ((amntDue - (amntAuthd + (eqHD * myHDRate))) < (44 * myHDRate))) 
				// this is the last auth and the total amount authed is less than the total equivalent, and the excess can fit on this auth (total + excess is less than 44 * HDRate)
				{
					myExcess = (amntDue - (amntAuthd + (eqHD * myHDRate)));
				}
			}
			if((SeqHD < 44) && (totalSummerAuthd + SeqHD >= Math.floor(targetSummerAuth)))
			{
				if(((summerAmntAuthd + (SeqHD * myHDRate)) < summerAmntDue) && ((summerAmntDue - (summerAmntAuthd + (SeqHD * myHDRate))) < (44 * myHDRate))) 
				// this is the last auth and the total amount authed is less than the total equivalent, and the excess can fit on this auth (total + excess is less than 44 * HDRate)
				{
					mySummerExcess = (summerAmntDue - (summerAmntAuthd + (SeqHD * myHDRate)));
				}
			}
			// if eqHD != SeqHD or myExcess != mySummerExcess then summerChg = true
			if(eqHD != SeqHD || myExcess != mySummerExcess)
			{
				summerChg = true;
			}
			// update the totals
			myRate = myHDRate * eqHD;
			mySummerRate = myHDRate * SeqHD;
			totalAuthd += eqHD;
			totalSummerAuthd += SeqHD;
			amntAuthd += ((myHDRate * eqHD) + myExcess);
			summerAmntAuthd += ((myHDRate * SeqHD) + mySummerExcess);
			
			// add the line(s)
			if((eqHD + myExcess + mySummerExcess + SeqHD) > 0)
			{
				if(eqHD > 0 || myExcess > 0)
				{
					authLines.push({type: myType, xCode: xCode, authUnits: 1, amt: myRate, units: {fd: 0, hd: eqHD, pd: 0, hr: 0}, excess: myExcess, inc: true, msg:'', rates:{fd: myFDRate, hd: myHDRate, pd: myPDRate, hr: 0}});
				}
				else
				{
					summerChg = true; // line is only included in summer care
				}
				summerLines.push({type: myType, xCode: xCode, authUnits: 1, amt: mySummerRate, units: {fd: 0, hd: SeqHD, pd: 0, hr: 0}, excess: mySummerExcess, inc: true, msg:'', rates:{fd: myFDRate, hd: myHDRate, pd: myPDRate, hr: 0}});
				}
			else
			{
				totalAuthd = targetAuth;
				amntAuthd = amntDue;
			}
			// if excess care was added, this is the last line, ensure the while loop ends
			if(myExcess > 0)
			{
				totalAuthd = targetAuth;
				amntAuthd = amntDue;
			}
			if(mySummerExcess > 0)
			{
				totalSummerAuthd = targetSummerAuth;
				summerAmntAuthd = summerAmntDue;
			}
		}
		// calculate and add NSHB lines here
		if(calculationResult.SummerNonStandardTime >= 1800) // 30 hours
		{
			xCode = (calculationResult.multProvs && !calculationResult.isPrimary) ? '9' : '0'; // 9 coded if this is not the primary provider
			myType = myBaseType + 'NSHB';
			myRate = getRate(calculationResult.providerType,"All","A", calculationResult.startDate, "NSHB");
			
			if(summerLines.length > 0)
			{
				summerLines.push({type: myType, xCode: xCode, authUnits: 1, amt: myRate, units: {fd: 0, hd: 0, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: 0, pd: 0, hr: 0}});
				if((calculationResult.nonStandardTime >= 1800) && (authLines.length > 0))
				{
					authLines.push({type: myType, xCode: xCode, authUnits: 1, amt: myRate, units: {fd: 0, hd: 0, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: 0, pd: 0, hr: 0}});
				}
				else{
					summerChg = true;
				}
			}
		}
	}
	if(authLines.length === 0)
	{
		authLines.push({type: 'Err', xCode: '0', authUnits: 0, amt: 0, units: {fd: 0, hd: 0, pd: 0, hr: 0}, excess: 0, inc: false, msg:'No care needed.', rates:{fd: 0, hd: 0, pd: 0, hr: 0}});
	}
	return {authLines: authLines, summerLines: summerLines, summerChg: summerChg};
}

// FFN Hourly Authorizations
function determineHourlyAuthorizations(calculationResult, non9CodeRemain)
{
	let summerChg = false;
	const authLines = [];
	const summerLines = [];
	
	if(Math.max(calculationResult.totalTime, calculationResult.SummerTotalTime) > 0.0)
	{
		// First set up the metric for when sufficient care has been authorized.
		let xCode = '0';
		let myUnits = 0;
		let mySummerUnits = 0;
		let myRate = getRate('F',getAgeGroup('F', calculationResult.ageMonths, calculationResult.schoolAge, calculationResult.startDate),calculationResult.region, calculationResult.startDate, "Hour");
		let totalAuthd = 0;
		let targetAuth = Math.ceil(calculationResult.totalTime/60.0);
		let totalSummerAuthd = 0;
		let targetSummerAuth = Math.max(targetAuth, Math.ceil(calculationResult.SummerTotalTime/60.0)); // don't reduce care for  summer
		let myType = 'FFN' + (calculationResult.locCare === 'P' ? 'PrrHome' : (calculationResult.subLoc === 'M' ? 'MutHome' : 'ClHome'));
		
		summerChg = ((calculationResult.multProvs) && (calculationResult.schoolAge) && ((Math.ceil(calculationResult.SummerTotalTime) > Math.ceil(calculationResult.totalTime))));
		
		while ((totalAuthd < targetAuth) && (totalSummerAuthd < targetSummerAuth))
		{
			xCode = (((calculationResult.multProvs && !calculationResult.isPrimary) || (Math.max(summerLines.length, authLines.length) > 1) || (non9CodeRemain <= 0)) ? '9' : '0');
			if(xCode === '9')
			{
				myUnits = Math.min(230,targetAuth-totalAuthd);
				mySummerUnits = Math.min(230,targetSummerAuth-totalSummerAuthd);
				
				if(Math.max(myUnits, mySummerUnits) <= non9CodeRemain) // If the total care is still under the full time limit, don't 9 code this line
				{
					xCode = '0';
					non9CodeRemain -= Math.max(myUnits, mySummerUnits);
				}
				
				if(myUnits > 0)
				{
					totalAuthd += myUnits;
					authLines.push({type: myType, xCode: xCode, authUnits: myUnits, amt: myRate, units: {fd: 0, hd: 0, pd: 0, hr: myUnits}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: 0, pd: 0, hr: myRate}});
				}
				if((myUnits <= 0) || (mySummerUnits > myUnits)){
					summerChg = true;
				}
				totalSummerAuthd += mySummerUnits;
				summerLines.push({type: myType, xCode: xCode, authUnits: mySummerUnits, amt: myRate, units: {fd: 0, hd: 0, pd: 0, hr: mySummerUnits}, excess:0, inc: true, msg:'', rates:{fd: 0, hd: 0, pd: 0, hr: myRate}});
			}
			else // this is the first line authorized to the primary provider '0' coded line
			{
				myUnits = Math.min(230,targetAuth-totalAuthd);
				mySummerUnits = Math.min(230,targetSummerAuth-totalSummerAuthd);
				let myEqAuthd = myUnits;
				
				if((calculationResult.meets110) && !(calculationResult.multProvs)){
					myUnits = 230;
					mySummerUnits = 230;
					myEqAuthd = 230;
					if(calculationResult.schoolAge){
						if(targetAuth <= 115){
							myUnits = 115;
							mySummerUnits = 230;
							myEqAuthd = 230;
						}
					}
				}
				non9CodeRemain -= Math.max(myUnits, mySummerUnits);
				authLines.push({type: myType, xCode: '0', authUnits: myUnits, amt: myRate, units: {fd: 0, hd: 0, pd: 0, hr: myUnits}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: 0, pd: 0, hr: myRate}});
				summerLines.push({type: myType, xCode: '0', authUnits: mySummerUnits, amt: myRate, units: {fd: 0, hd: 0, pd: 0, hr: mySummerUnits}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: 0, pd: 0, hr: myRate}});
				if(mySummerUnits != myEqAuthd){
					summerChg = true;
				}
				totalAuthd += myEqAuthd;
				totalSummerAuthd += mySummerUnits;
			}
		}
	}
	if(authLines.length === 0)
	{
		authLines.push({type: 'Err', xCode: '0', authUnits: 0, amt: 0, units: {fd: 0, hd: 0, pd: 0, hr: 0}, excess: 0, inc: false, msg:'No care needed.', rates:{fd: 0, hd: 0, pd: 0, hr: 0}});
	}
	return {authLines: authLines, summerLines: summerLines, summerChg: summerChg};
}

// Center Daily Unit type Authorizations (FDU, HDU, OTU)
function determineDailyAuthorizations(calculationResult, non9CodeRemain)
{
	let summerChg = false;
	const authLines = [];
	const summerLines = [];
	
	if(Math.max(calculationResult.totalTime, calculationResult.SummerTotalTime) > 0.0)
	{
		let xCode = '0';
		let myUnits = 0;
		let mySummerUnits = 0;
		let myFDRate = getRate(calculationResult.providerType,getAgeGroup(calculationResult.providerType, calculationResult.ageMonths, calculationResult.schoolAge, calculationResult.startDate),calculationResult.region, calculationResult.startDate, "Full Day");
		let myHDRate = getRate(calculationResult.providerType,getAgeGroup(calculationResult.providerType, calculationResult.ageMonths, calculationResult.schoolAge, calculationResult.startDate),calculationResult.region, calculationResult.startDate, "Half Day");
		let myBaseType = calculationResult.providerType === 'C' ? 'CC' : 'LFH';
		let myType = myBaseType;
		let totalAuthd = 0;
		let totalSummerAuthd = 0;
		//let FDUremain = calculationResult.normFull;
		//let HDUremain = calculationResult.normHalf;
		let OTUremain = calculationResult.overTimeUnits;
		//let summerFDUremain = calculationResult.SummerNormFull;
		//let summerHDUremain = calculationResult.SummerNormHalf;
		let summerOTUremain = calculationResult.SummerOverTimeUnits;
		let summerNon9CodeRemain = non9CodeRemain;
		let FDUremain = ((Math.ceil((Math.min(5, calculationResult.schoolWeeklyFD) * 52.0)/12.0)) + Math.ceil((calculationResult.schoolWeeklyFD > 5 ? (((calculationResult.schoolWeeklyFD - 5) * 52.0)/12.0) : 0)));
		let HDUremain = ((Math.ceil((Math.min(5, calculationResult.schoolWeeklyHD) * 52.0)/12.0)) + Math.ceil((calculationResult.schoolWeeklyHD > 5 ? (((calculationResult.schoolWeeklyHD - 5) * 52.0)/12.0) : 0)));
		let summerFDUremain = ((Math.ceil((Math.min(5, calculationResult.weeklyFD) * 52.0)/12.0)) + Math.ceil((calculationResult.weeklyFD > 5 ? (((calculationResult.weeklyFD - 5) * 52.0)/12.0) : 0)));
		let summerHDUremain = ((Math.ceil((Math.min(5, calculationResult.weeklyHD) * 52.0)/12.0)) + Math.ceil((calculationResult.weeklyHD > 5 ? (((calculationResult.weeklyHD - 5) * 52.0)/12.0) : 0)));
		
		// If this is the only provider and the family meets the 110 hour rule, authorize 23 FDU or 30 HDU for school aged child
		// Then determine which care units have already been covered by the blanket authorization
		if(calculationResult.isPrimary && !calculationResult.multProvs && calculationResult.meets110)
		{
			non9CodeRemain = 0; // Full time equivalent will be authorized
			summerNon9CodeRemain = 0;
			if((calculationResult.schoolWeeklyFD >= calculationResult.schoolWeeklyHD) || calculationResult.schoolAge === false || ((calculationResult.schoolWeeklyFD > 0) && (calculationResult.schoolWeeklyFD + calculationResult.schoolWeeklyHD <= 5))) // will be minimum 23 FDU
			{
				myType += 'FDU';
				myUnits = 23;
				mySummerUnits = 23;
				if(calculationResult.schoolWeeklyFD + calculationResult.schoolWeeklyHD <= 5)
				{
					FDUremain = 0;
					HDUremain = 0;
				}
				else
				{
					if(calculationResult.schoolWeeklyFD >= 5)
					{
						FDUremain = Math.ceil(((calculationResult.schoolWeeklyFD - 5) * 52.0)/12.0);
					}
					else
					{
						FDUremain = 0;
						HDUremain = Math.ceil(((calculationResult.schoolWeeklyHD - (5 - calculationResult.schoolWeeklyFD))*52.0)/12.0);
					}
				}
				
				authLines.push({type: myType, xCode: xCode, authUnits: myUnits, amt: myFDRate, units: {fd: 23, hd: 0, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: myFDRate, hd: 0, pd: 0, hr: 0}});
				
				if(calculationResult.weeklyFD + calculationResult.weeklyHD <= 5)
				{
					summerFDUremain = 0;
					summerHDUremain = 0;
				}
				else
				{
					if(calculationResult.weeklyFD >= 5)
					{
						summerFDUremain = Math.ceil(((calculationResult.weeklyFD - 5) * 52.0)/12.0);
					}
					else
					{
						summerFDUremain = 0;
						summerHDUremain = Math.ceil(((calculationResult.weeklyHD - (5 - calculationResult.weeklyFD))*52.0)/12.0);
					}
				}
				summerLines.push({type: myType, xCode: xCode, authUnits: mySummerUnits, amt: myFDRate, units: {fd: 23, hd: 0, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: myFDRate, hd: 0, pd: 0, hr: 0}});
			}
			else // will be minimum 30 HDU
			{
				myType += 'SDU'; // school half day unit
				myUnits = 30;
				mySummerUnits = 46;
				
				if(calculationResult.schoolWeeklyHD <= 5)
				{
					HDUremain = 0;
				}
				else
				{
					HDUremain = (((calculationResult.schoolWeeklyHD - 5)*52.0)/12.0);
				}
				authLines.push({type: myType, xCode: xCode, authUnits: myUnits, amt: myHDRate, units: {fd: 0, hd: 30, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: myHDRate, pd: 0, hr: 0}});
				
				if(calculationResult.weeklyFD + calculationResult.weeklyHD <= 5)
				{
					summerFDUremain = 0;
					summerHDUremain = 0;
				}
				else
				{
					if(calculationResult.weeklyFD >= 5)
					{
						summerFDUremain = Math.ceil(((calculationResult.weeklyFD - 5) * 52.0)/12.0);
					}
					else
					{
						summerFDUremain = 0;
						summerHDUremain = Math.ceil(((calculationResult.weeklyHD - (5 - calculationResult.weeklyFD))*52.0)/12.0);
					}
				}
				summerLines.push({type: myType, xCode: xCode, authUnits: mySummerUnits, amt: myHDRate, units: {fd: 0, hd: 46, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: myHDRate, pd: 0, hr: 0}});
			}
		}
		// Check if there is still any normal care to authorize (if we didn't meet the above criteria or if it didn't cover all normal care
		// Authorize individual lines for full days and any half days required
		if((FDUremain > 0) || (HDUremain > 0) || (summerFDUremain > 0) || (summerHDUremain > 0))
		{
			// get an optimal set of authorization results that minimizes 9 code actions, authorized lines, and maximizes use of available 0 coded time remaining
			if(verboseReporting)
			{
				console.log(`FDUremain ${FDUremain}, HDUremain ${HDUremain}, non9CodeRemain ${non9CodeRemain}, summerFDUremain ${summerFDUremain}, summerHDUremain ${summerHDUremain}, summerNon9CodeRemain${summerNon9CodeRemain}`);
			}
			const optResults = calculateOptimalCareAuthorizations(FDUremain, HDUremain, non9CodeRemain, summerFDUremain, summerHDUremain, summerNon9CodeRemain)
			summerChg = optResults.summerChg; // update summerChg based on optimal result
			
			// add actual lines to the authLines and summerLines arrays
			optResults.authLines.forEach(a => {
				if(a.unitType === 'HDU')
				{
					HDUremain -= a.myUnits;
				}
				else
				{
					FDUremain -= a.myUnits;
				}
				authLines.push({type: myBaseType + a.unitType, xCode: a.xCode, authUnits: a.myUnits, amt: (a.unitType === 'HDU' ? myHDRate : myFDRate), units: {fd: (a.unitType === 'FDU' ? a.myUnits : 0), hd: (a.unitType === 'HDU' ? a.myUnits : 0), pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: (a.unitType === 'FDU' ? a.myFDRate : 0), hd: (a.unitType === 'HDU' ? a.myHDRate : 0), pd: 0, hr: 0}});
			});
			
			optResults.summerAuthLines.forEach(a => {
				if(a.unitType === 'HDU')
				{
					summerHDUremain -= a.myUnits;
				}
				else
				{
					summerFDUremain -= a.myUnits;
				}
				summerLines.push({type: myBaseType + a.unitType, xCode: a.xCode, authUnits: a.myUnits, amt: (a.unitType === 'HDU' ? myHDRate : myFDRate), units: {fd: (a.unitType === 'FDU' ? a.myUnits : 0), hd: (a.unitType === 'HDU' ? a.myUnits : 0), pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: (a.unitType === 'FDU' ? a.myFDRate : 0), hd: (a.unitType === 'HDU' ? a.myHDRate : 0), pd: 0, hr: 0}});
			});
		}
		// log issue if we get here and still have normal care to authorize
		if(((FDUremain > 0) || (HDUremain > 0) || (summerFDUremain > 0) || (summerHDUremain > 0)) &&(verboseReporting))
		{
			console.log(`ERROR: DailyUnitOptimization failed to assign all care: FDUremain - ${FDUremain}, HDUremain - ${HDUremain}, summerFDUremain - ${summerFDUremain}, summerHDUremain - ${summerHDUremain}.`); 
		}
		
		if(OTUremain != summerOTUremain)
		{
			summerChg = true;
		}
		// Last, while there are additional full days, half days, and or overtime units required, add additional 9 coded lines for the additional care.
		myType = myBaseType + 'OTU';
		xCode = '9';
		while(OTUremain > 0 || summerOTUremain > 0) // Authorize the 9 coded overtime care line(s)
		{
			if(OTUremain > 0)
			{
				let myOTU = Math.min(22, OTUremain);
				OTUremain -= myOTU;
				authLines.push({type: myType, xCode: xCode, authUnits: myOTU, amt: myHDRate, units: {fd: 0, hd: myOTU, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: myHDRate, pd: 0, hr: 0}});
			}
			if(summerOTUremain > 0)
			{
				let myOTU = Math.min(22, summerOTUremain);
				summerOTUremain -= myOTU;
				summerLines.push({type: myType, xCode: xCode, authUnits: myOTU, amt: myHDRate, units: {fd: 0, hd: myOTU, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: myHDRate, pd: 0, hr: 0}});
			}
		}
		
		// lastly, calculate and add NSHB lines here
		if(calculationResult.SummerNonStandardTime >= 1800) // 30 hours
		{
			xCode = (calculationResult.multProvs && !calculationResult.isPrimary) ? '9' : '0'; // 9 coded if this is not the primary provider
			myType = myBaseType + 'NSHB';
			myRate = getRate(calculationResult.providerType,"All","A", calculationResult.startDate, "NSHB");
			
			if(summerLines.length > 0)
			{
				summerLines.push({type: myType, xCode: xCode, authUnits: 1, amt: myRate, units: {fd: 0, hd: 0, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: 0, pd: 0, hr: 0}});
				if((calculationResult.nonStandardTime >= 1800) && (authLines.length > 0))
				{
					authLines.push({type: myType, xCode: xCode, authUnits: 1, amt: myRate, units: {fd: 0, hd: 0, pd: 0, hr: 0}, excess: 0, inc: true, msg:'', rates:{fd: 0, hd: 0, pd: 0, hr: 0}});
				}
				else{
					summerChg = true;
				}
			}
		}
	}
	if(authLines.length === 0)
	{
		authLines.push({type: 'Err', xCode: '0', authUnits: 0, amt: 0, units: {fd: 0, hd: 0, pd: 0, hr: 0}, excess: 0, inc: false, msg:'No care needed.', rates:{fd: 0, hd: 0, pd: 0, hr: 0}});
	}
	return {authLines: authLines, summerLines: summerLines, summerChg: summerChg};
}

// Functions for Daily Unit Authorization Optimization

function calculateOptimalCareAuthorizations(schoolFull, schoolHalf, schoolZero,summerFull, summerHalf, summerZero)
{
	// Find optimal solution... by brute force
	let bestSolution = null;
	let bestScore = { events: Infinity, modifications: -Infinity, lines: Infinity, zeroUsed: -Infinity };
  
	// Try all possible allocations of 0-coded hours
	for (let schoolHalfZero = 0; schoolHalfZero <= Math.min(schoolHalf, Math.floor(schoolZero / 5)); schoolHalfZero++) 
	{
		const remainingSchoolZero = schoolZero - (schoolHalfZero * 5);
		for (let schoolFullZero = 0; schoolFullZero <= Math.min(schoolFull, Math.floor(remainingSchoolZero / 10)); schoolFullZero++) 
		{
			for (let summerHalfZero = 0; summerHalfZero <= Math.min(summerHalf, Math.floor(summerZero / 5)); summerHalfZero++) 
			{
				const remainingSummerZero = summerZero - (summerHalfZero * 5);
				for (let summerFullZero = 0; summerFullZero <= Math.min(summerFull, Math.floor(remainingSummerZero / 10)); summerFullZero++) 
				{
					const eventBreakdown = count9Events(schoolFull, schoolHalf, schoolZero,summerFull, summerHalf, schoolFullZero, schoolHalfZero, summerFullZero, summerHalfZero);
					  
					// Create simple lines just for counting max lines
					const schoolLineCount = Math.ceil((schoolFullZero + summerFullZero) / 22) + 
										 Math.ceil((schoolHalfZero + summerHalfZero) / 22) +
										 (schoolFull - schoolFullZero > 0 ? 1 : 0) +
										 (schoolHalf - schoolHalfZero > 0 ? 1 : 0);
					const summerLineCount = Math.ceil((summerFullZero + summerHalfZero) / 22) +
										 (summerFull - summerFullZero > 0 ? 1 : 0) +
										 (summerHalf - summerHalfZero > 0 ? 1 : 0);
					const maxLines = Math.max(schoolLineCount, summerLineCount);
					const zeroUsed = (schoolFullZero * 10) + (schoolHalfZero * 5) + (summerFullZero * 10) + (summerHalfZero * 5);
					  
					// Optimization priorities
					const isBetter = (
						eventBreakdown.total < bestScore.events ||
						(eventBreakdown.total === bestScore.events && 
						 eventBreakdown.modifications > bestScore.modifications) ||
						(eventBreakdown.total === bestScore.events && 
						 eventBreakdown.modifications === bestScore.modifications && 
						 maxLines < bestScore.lines) ||
						(eventBreakdown.total === bestScore.events && 
						 eventBreakdown.modifications === bestScore.modifications && 
						 maxLines === bestScore.lines && 
						 zeroUsed > bestScore.zeroUsed));
					  
					if (isBetter) 
					{
						bestScore = { 
							events: eventBreakdown.total, 
							modifications: eventBreakdown.modifications,
							lines: maxLines, 
							zeroUsed};
						bestSolution = { 
							schoolFullZero,
							schoolHalfZero,
							summerFullZero,
							summerHalfZero};
					}
				}
			}
		}
	}
  
	// Create the final aligned output
	const { schoolLines, summerLines } = createAlignedOutput(schoolFull, schoolHalf, schoolZero,summerFull, summerHalf, bestSolution.schoolFullZero, bestSolution.schoolHalfZero, bestSolution.summerFullZero, bestSolution.summerHalfZero);
  
	// Determine if summer changes are needed
	const summerChg = ((schoolLines.length !== summerLines.length) || (schoolLines.some(l => summerLines.find(s => s.unitType === l.unitType && s.xCode === l.xCode) === null)));
  
	return {
		authLines: schoolLines,
		summerAuthLines: summerLines,
		summerChg: summerChg};
}


// Count 9-coded events for a specific allocation
function count9Events(schoolFull, schoolHalf, schoolZero,summerFull, summerHalf, schoolFullZero, schoolHalfZero, summerFullZero, summerHalfZero) 
{
	const schoolFullNine = schoolFull - schoolFullZero;
	const schoolHalfNine = schoolHalf - schoolHalfZero;
	const summerFullNine = summerFull - summerFullZero;
	const summerHalfNine = summerHalf - summerHalfZero;

	let events = 0;
	let modifications = 0;

	// Initial creation of 9-coded lines in school
	if (schoolFullNine > 0) events++;
	if (schoolHalfNine > 0) events++;

	// Handle full-time 9-coded line transitions
	if (schoolFullNine > 0 && summerFullNine > 0) {
	  // Both periods have 9-coded full lines - can modify
	  if (schoolFullNine !== summerFullNine) {
		events += 2; // modify for summer + modify back
		modifications += 2;
	  }
	} else if (schoolFullNine > 0 && summerFullNine === 0) {
	  // School has 9-coded full but summer doesn't - close and reopen
	  events += 2;
	} else if (schoolFullNine === 0 && summerFullNine > 0) {
	  // Summer has 9-coded full but school doesn't - create and close
	  events += 2;
	}

	// Handle half-time 9-coded line transitions
	if (schoolHalfNine > 0 && summerHalfNine > 0) {
	  // Both periods have 9-coded half lines - can modify
	  if (schoolHalfNine !== summerHalfNine) {
		events += 2; // modify for summer + modify back
		modifications += 2;
	  }
	} else if (schoolHalfNine > 0 && summerHalfNine === 0) {
	  // School has 9-coded half but summer doesn't - close and reopen
	  events += 2;
	} else if (schoolHalfNine === 0 && summerHalfNine > 0) {
	  // Summer has 9-coded half but school doesn't - create and close
	  events += 2;
	}

	return { total: events, modifications };
}

// Create formatted authorization lines with proper alignment for output
function createAlignedOutput(schoolFull, schoolHalf, schoolZero,summerFull, summerHalf, schoolFullZero, schoolHalfZero, summerFullZero, summerHalfZero) 
{
	const schoolFullNine = schoolFull - schoolFullZero;
	const schoolHalfNine = schoolHalf - schoolHalfZero;
	const summerFullNine = summerFull - summerFullZero;
	const summerHalfNine = summerHalf - summerHalfZero;

	const schoolLines = [];
	const summerLines = [];

	// 0-coded lines that exist year-round (never change)
	const yearRoundHalfZero = Math.min(schoolHalfZero, summerHalfZero);
	const yearRoundFullZero = Math.min(schoolFullZero, summerFullZero);

	// Add year-round 0-coded half lines
	let remaining = yearRoundHalfZero;
	while (remaining > 0) {
	  const units = Math.min(22, remaining);
	  schoolLines.push({myUnits: units, unitType: 'HDU', xCode: '0'});
	  summerLines.push({myUnits: units, unitType: 'HDU', xCode: '0'});
	  remaining -= units;
	}

	// Add year-round 0-coded full lines
	remaining = yearRoundFullZero;
	while (remaining > 0) {
	  const units = Math.min(22, remaining);
	  schoolLines.push({myUnits: units, unitType: 'FDU', xCode: '0'});
	  summerLines.push({myUnits: units, unitType: 'FDU', xCode: '0'});
	  remaining -= units;
	}

	// 0-coded lines that change between periods
	const schoolOnlyHalfZero = schoolHalfZero - yearRoundHalfZero;
	const summerOnlyHalfZero = summerHalfZero - yearRoundHalfZero;
	const schoolOnlyFullZero = schoolFullZero - yearRoundFullZero;
	const summerOnlyFullZero = summerFullZero - yearRoundFullZero;

	// Add changing 0-coded half lines
	const maxHalfZeroLines = Math.max(
	  schoolOnlyHalfZero > 0 ? Math.ceil(schoolOnlyHalfZero / 22) : 0,
	  summerOnlyHalfZero > 0 ? Math.ceil(summerOnlyHalfZero / 22) : 0
	);

	let schoolHalfZeroRemaining = schoolOnlyHalfZero;
	let summerHalfZeroRemaining = summerOnlyHalfZero;

	for (let i = 0; i < maxHalfZeroLines; i++) {
	  const schoolUnits = Math.min(22, schoolHalfZeroRemaining);
	  const summerUnits = Math.min(22, summerHalfZeroRemaining);
	  
	  if (schoolUnits > 0) {
		schoolLines.push({myUnits: schoolUnits, unitType: 'HDU', xCode: '0'});
		schoolHalfZeroRemaining -= schoolUnits;
	  } else {
		schoolLines.push(null);
	  }
	  
	  if (summerUnits > 0) {
		summerLines.push({myUnits: summerUnits, unitType: 'HDU', xCode: '0'});
		summerHalfZeroRemaining -= summerUnits;
	  } else {
		summerLines.push(null);
	  }
	}

	// Add changing 0-coded full lines
	const maxFullZeroLines = Math.max(
	  schoolOnlyFullZero > 0 ? Math.ceil(schoolOnlyFullZero / 22) : 0,
	  summerOnlyFullZero > 0 ? Math.ceil(summerOnlyFullZero / 22) : 0
	);

	let schoolFullZeroRemaining = schoolOnlyFullZero;
	let summerFullZeroRemaining = summerOnlyFullZero;

	for (let i = 0; i < maxFullZeroLines; i++) {
	  const schoolUnits = Math.min(22, schoolFullZeroRemaining);
	  const summerUnits = Math.min(22, summerFullZeroRemaining);
	  
	  if (schoolUnits > 0) {
		schoolLines.push({myUnits: schoolUnits, unitType: 'FDU', xCode: '0'});
		schoolFullZeroRemaining -= schoolUnits;
	  } else {
		schoolLines.push(null);
	  }
	  
	  if (summerUnits > 0) {
		summerLines.push({myUnits: summerUnits, unitType: 'FDU', xCode: '0'});
		summerFullZeroRemaining -= summerUnits;
	  } else {
		summerLines.push(null);
	  }
	}

	// 9-coded lines that exist year-round but may be modified
	if (schoolFullNine > 0 && summerFullNine > 0) {
	  // This line exists in both periods - may be modified
	  schoolLines.push({myUnits: schoolFullNine, unitType: 'FDU', xCode: '9'});
	  summerLines.push({myUnits: summerFullNine, unitType: 'FDU', xCode: '9'});
	}

	if (schoolHalfNine > 0 && summerHalfNine > 0) {
	  // This line exists in both periods - may be modified
	  schoolLines.push({myUnits: schoolHalfNine, unitType: 'HDU', xCode: '9'});
	  summerLines.push({myUnits: summerHalfNine, unitType: 'HDU', xCode: '9'});
	}

	// 9-coded lines that are created/closed between periods
	if (schoolFullNine > 0 && summerFullNine === 0) {
	  schoolLines.push({myUnits: schoolFullNine, unitType: 'FDU', xCode: '9'});
	  summerLines.push(null);
	} else if (schoolFullNine === 0 && summerFullNine > 0) {
	  schoolLines.push(null);
	  summerLines.push({myUnits: summerFullNine, unitType: 'FDU', xCode: '9'});
	}

	if (schoolHalfNine > 0 && summerHalfNine === 0) {
	  schoolLines.push({myUnits: schoolHalfNine, unitType: 'HDU', xCode: '9'});
	  summerLines.push(null);
	} else if (schoolHalfNine === 0 && summerHalfNine > 0) {
	  schoolLines.push(null);
	  summerLines.push({myUnits: summerHalfNine, unitType: 'HDU', xCode: '9'});
	}

	// Remove nulls and return aligned arrays
	const cleanSchoolLines = schoolLines.filter(line => line !== null);
	const cleanSummerLines = summerLines.filter(line => line !== null);

	return { schoolLines: cleanSchoolLines, summerLines: cleanSummerLines };
}

// End of authorization Calculation Functions

// Initialize the application
function init() {
	refreshPeopleList();
	refreshProvidersList();
	refreshApplicationsList();
	refreshHouseholdForm();
	refreshHouseholdList();
	refreshActivityForm();
	refreshActivitiesList();
	refreshProviderLinkForm();
	refreshProviderLinksList();
	refreshScheduleSelector();
	refreshCalculationForm();
	refreshSavedResults();
	document.getElementById('repCheckbox').checked = verboseReporting;
}

function refreshAll()
{
	refreshPeopleList();
	refreshProvidersList();
	refreshApplicationsList();
	refreshHouseholdForm();
	refreshHouseholdList();
	refreshActivityForm();
	refreshActivitiesList();
	refreshProviderLinkForm();
	refreshProviderLinksList();
	refreshScheduleSelector();
	refreshCalculationForm();
	refreshSavedResults();
	document.getElementById('repCheckbox').checked = verboseReporting;
}

// Run initialization when page loads
window.onload = init;
</script>
</body>

</html>
